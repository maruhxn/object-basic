# 절차적인 방식 개선하기

## 책임 이동: 데이터와 프로세스 통합하기

1. **_데이터의 getter를 사용해서 판단하고 결정하는 로직을 그 데이터로 옮겨라_**
   - = 다른 클래스의 데이터를 이용해서 의사결정을 하거나 데이터를 제공한 클래스의 상태를 변경하는 로직이 있다면, 이 로직을 데이터를 보유한 클래스 쪽으로 옮겨야함
   - => 데이터가 수정될 때 변경의 영향 범위를 데이터 클래스 내부로 제한 가능
   - ex) `findDiscountCondition` 메서드의 `condition.isPeriodCondition()`을 체크하는 분기문 부분을
   - 객체지향에서는 이를 **'책임의 이동(Shift of Responsibility)'** 라고 함
     - `책임`: **데이터를 이용해서 의사 결정하거나, 데이터의 상태를 변경하는 로직** (절차지향에서는 이를 '프로세스'라고 불렀음)

ex) findDiscountCondition 리팩토링(책임 이동)

```java
private DiscountCondition findDiscountCondition(Screening screening, List<DiscountCondition> conditions) {
    // 루프를 돌며 DiscountCondition의 타입이 기간 조건인지 체크하고, 상영 시간을 이용해서 할인 여부 판단
    for (DiscountCondition condition : conditions) {
        if (condition.isPeriodCondition()) { // 기간 조건이라면
            if (screening.isPlayedIn(condition.getDayOfWeek(),
                    condition.getStartTime(),
                    condition.getEndTime())) {
                return condition;
            }
        } else { // 순서 조건이라면
            if (condition.getSequence().equals(screening.getSequence())) { // 상영의 회차를 이용해서 할인 여부 판단
                return condition;
            }
        }
    }

    return null;
}
```

위 코드를 다음과 같이 수정

```java
private DiscountCondition findDiscountCondition(Screening screening, List<DiscountCondition> conditions) {
    // 루프를 돌며 DiscountCondition의 타입이 기간 조건인지 체크하고, 상영 시간을 이용해서 할인 여부 판단
    for (DiscountCondition condition : conditions) {
        if (condition.isSatisfiedBy(screening)) { // 기간 조건이라면
            return condition;
        }
    }

    return null;
}
```

이후 `DiscountCondition`에 다음의 메서드 추가 & 불필요한 Getter들 제거

```java
// DiscountCondition
public boolean isSatisfiedBy(Screening screening) {
    if (isPeriodCondition()) {
        if (screening.isPlayedIn(this.dayOfWeek(),
                this.startTime,
                this.endTime)) {
            return true;
        }
    } else {
        if (this.sequence.equals(screening.getSequence())) {
            return true;
        }
    }

    return false;
}

// public DayOfWeek getDayOfWeek() { ... } // 제거
// public LocalDateTime getStartTime() { ... } // 제거
// public LocalDateTime getEndTime() { ... } // 제거
// public Integer getDayOfWeek() { ... } // 제거
```

=> 내부의 데이터는 외부에 전혀 노출시키지 않고 오직 할인 여부를 판단할 수 있다는 사실만 공개
=> DiscountCondition은 자기 잣니을 책임지고 있음

ex) calculateDiscount 리팩토링 (책임 이동)

```java
private Money calculateDiscount(DiscountPolicy policy, Movie movie) {
    if (policy.isAmountPolicy()) {
        return policy.getAmount();
    } else if (policy.isPercentPolicy()) {
        return movie.getFee().times(policy.getPercent());
    }

    return Money.ZERO;
}
```

위 코드를 삭제 후, reserveScreening을 다음과 같이 변경

```java
 public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {

    ...

    List<DiscountCondition> conditions = discountConditionDAO.selectDiscountConditions(policy.getId());

    DiscountCondition condition = findDiscountCondition(screening, conditions);

    Money discountAmount;
    if (condition != null) { // null이 아니라면 할인 가능
        discountAmount = policy.calculateDiscount(movie);
    } else { // 할인 불가능
        discountAmount = Money.ZERO;
    }

    ...

    return reservation;
}
```

이후 `DiscountPolicy`에 다음의 메서드 추가 & 불필요한 Getter들 제거 & 접근제어자 변경

```java
public Money calculateDiscount(Movie movie) {
    if (isAmountPolicy()) {
        return amount;
    } else if (isPercentPolicy()) {
        return movie.getFee().times(percent);
    }

    return Money.ZERO;
}

private boolean isAmountPolicy() { ...} // private로 변경
private boolean isPercentPolicy() { ...} // private로 변경

// public Money getAmount() //제거
// public Double getPercent() //제거
```

=> DiscountPolicy는 자기 자신을 책임짐

하지만, 여전히 과도한 의존성이 남아있음..
다수의 데이터에 의존하는 프로세스 ex) ReservationService는 DiscountPolicy와 DiscountCondition이 변경될 때마다 영향을 받음
=> ReservationService가 DiscountPolicy와 DiscountCondition 둘 중 하나에만 의존하도록 변경한다면??

이렇게 **의존하는 객체 수를 줄이기 위해서는 도메인의 구조를 기반으로 객체의 구조를 변경해야 함**

> 데이터 vs 객체
>
> 클래스 안에 구현된 로직의 특성에 따라 클래스의 인스턴스는 데이터가 될 수도 있고, 객체가 될 수도 있음
> 로직이 클래스의 인스턴스를 수동적인 존재로 만든다면? -> 이 클래스의 인스턴스는 '데이터'
> 로직이 클래스의 인스턴스를 능동적인 존재로 만든다면? -> 이 클래스의 인스턴스는 '객체'
> 인스턴스가 다른 객체의 판단에 의존하거나 세세한 의사결정을 외부에 의존한다면, 클래스로 구현되었다고 하더라도 이는 '데이터'라고 불러야 함
>
> 데이터와 객체 모두 클래스로 구현되다 보니 데이터를 진짜 객체와 명확히 구분하기 위해 데이터에 해당하는 인스턴스에 '바보 데이터 객체(Dumb Data Object)'라는 이름을 사용하기도 함
> 반면, 스스로를 책임질 수 있는 '객체'는 '똑똑한 객체(Smart Object)'라고 부르기도 함

- `객체(Object)`
  - **자기 자신의 상태를 직접 관리하고 스스로 판단하고 결정하는 자율적인 존재**
    - 자율적: 자기 스스로의 원칙에 따라 어떤 일을 하거나, 자기 스스로를 통제하여 절제하는 것
  - 특별한 설명없이 객체라고 할 때는 똑똑한 객체를 의미

## 객체 구조 변경: 절차에서 객체로

ReservationService가 DiscountPolicy와 DiscountCondition 중 하나의 클래스만 참조하도록 의존성을 줄여서 ReservationService의 수정 가능성을 줄여보자
-> 이를 위해서는 **객체의 구조를 변경해야 함**

할인 정책(DiscountPolicy)과 할인 조건(DiscountCondition)을 도메인에 표현된 구조에 따라 연결(연관관계 추가)하고,
ReservationService가 DiscountPolicy만 참조하도록 구조를 변경

1. DiscountPolicy와 DiscountCondition 사이에 연관 관계를 추가해주기 위해, 도메인 구조를 반영하여 DiscountPolicy에 `List<DiscountCondition> conditions` 필드를 추가

```java
public class DiscountPolicy {
    public enum PolicyType {PERCENT_POLICY, AMOUNT_POLICY}

    private Long id;
    private Long movieId;
    private PolicyType policyType;
    private Money amount;
    private Double percent;
    private List<DiscountCondition> conditions; // 연관관계 추가

    ...

}
```

2. 관계(구조)를 변경했다면 ReservationService 안에 있는 DiscountCodition의 책임을 DiscountPolicy로 이동시키기(의존성 제거)
   - 할인 여부를 판단하는 `findDiscountCondition` 메서드를 DiscountPolicy로 옮기기
   - `reserveScreening` 메서드 내부의 `findDiscountCondition`을 호출하는 부분을 `policy.findDiscountCondition()`을 호출하도록 변경
   - 이로써 ReservationService 안의 DiscountCondition에 대한 모든 의존성은 DiscountPolicy로 이동됨
   - => DiscountPolicy가 DiscountCondition을 숨기는 캡슐화 경계를 생성함
   - => ReservationService는 더 이상 DiscountCondition을 알 수 없음
   - => DiscountCondition이 수정되더라도 ReservationService는 영향을 받지 않음
   - => 새로운 할인 조건(DiscountCondition)이 추가되더라도, DiscountPolicy까지만 수정하면 됨 (변경에 용이)
   - => 코드 개선을 위해 DiscountCondition의 startTime, endTime을 묶는 TimeInterval 클래스를 도입하고 이를 필드로 사용하도록 변경하더라도 역시 ReservationService는 수정될 필요 없음(코드 개선 용이)

```java
public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {
    Screening screening = screeningDAO.selectScreening(screeningId);
    Movie movie = movieDAO.selectMovie(screening.getMovieId());
    DiscountPolicy policy = discountPolicyDAO.selectDiscountPolicy(movie.getId());
    boolean found = policy.findDiscountCondition(screening); // DiscountCondition에 대한 의존성 제거

    Money fee;
    if (found) {
        fee = movie.getFee().minus(policy.calculateDiscount(movie));
    } else {
        fee = movie.getFee();
    }

    Reservation reservation = makeReservation(customerId, screeningId, audienceCount, fee);
    reservationDAO.insert(reservation);

    return reservation;
}
```

```java
// DiscountCondition의 코드 개선을 위해 TimeInterval 도입
public class DiscountCondition {
    public enum ConditionType {PERIOD_CONDITION, SEQUENCE_CONDITION, COMBINED_CONDITION}

    private Long id;
    private Long policyId;
    private ConditionType conditionType;
    private DayOfWeek dayOfWeek;
    private TimeInterval interval; // startTime + endTime
    private Integer sequence;

    ...
}
```

```java
// 새로운 할인 조건인, 조합 조건(Combined Condition)이 추가되어도 DiscountCondition만 변경하면 됨
// + TimeInterval 코드 개선이 있더라도, 역시 DiscountCondition만 변경됨
// DiscountPolicy와 ReservationService에는 아무 변경없음
public boolean isSatisfiedBy(Screening screening) {
    if (isPeriodCondition()) {
        if (screening.isPlayedIn(dayOfWeek, interval.getStartTime(), interval.getEndTime())) {
            return true;
        }
    } else if (isSequenceCondition()){
        if (sequence.equals(screening.getSequence())) {
            return true;
        }
    } else if (isCombinedCondition()) {
        if (screening.isPlayedIn(dayOfWeek, interval.getStartTime(), interval.getEndTime()) &&
                sequence.equals(screening.getSequence())) {
            return true;
        }
    }

    return false;
}
```

처음부터 변경과 의존성을 고려해서 설계할 수 는 없었을까?

불행하게도, 절차적 방식에서는 변경과 읮노성 관점에서 시도해 볼 수 있는 방법에 제한이 있을 수 밖에 없다.
데이터가 사용될 문맥을 고려하지 않고 데이터를 설계하기 때문에, 데이터 수정 시 프로세스도 함께 수정될 수 밖에 없음

이를 해결하는 최선의 방법은 **객체 설계하기 시작하는 초기부터, 객체가 사용될 문맥을 함께 고려하는 것 뿐**
=> 객체가 사용될 문맥을 고려해서 데이터와 책임을 동일한 클래스 안에 모아둠으로써 객체 수정 시의 다른 코드에 미치는 파급 효과를 최소화할 수 있음
=> **객체를 설계할 때, 객체가 사용될 문맥을 함께 고려하는 설계 방법**을 '책임 주도 설계(Responsibility-Driven Design)'이라고 함
