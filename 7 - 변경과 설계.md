# 변경과 설계

## 변경과 설계

### 절차적인 방식과 객체지향 방식의 설계의 차이점

- 기능은 동일
- **코드를 배치하는 방식**
    - 절차적인 설계: 데이터와 기능을 별도의 모듈로 분리
    - 객체지향 설계: 데이터와 기능을 하나의 모듈로 통합

### 설계란?

- = 코드를 배치하는 방식
- 동일한 기능을 구현하는 코드를 서로 다른 방식으로 배치하면 서로 다른 설계가 됨

### 훌륭한 설계?

- 응집도가 높고
- 결합도가 낮고
- 캡슐화를 지키도록

코드를 배치하는 것

### 전통적인 의미의 응집도/결합도/캡슐화

- **응집도(Cohesion)**
    - **모듈(클래스) 내부의 특성**
    - 어떤 모듈 내부에 함께 포함된 요소들의 기능적인 집중도 또는 데이터와 메서드 간에 관련된 정도를 의미
    - 응집도가 높다/낮다로 표현
    - 응집도가 높은 설계 = 훌륭한 설계
- **결합도(Coupling)**
    - **모듈 외부의 특성**
    - 모듈이 외부의 다른 모듈에 의존하는 정도 또는 다른 모듈에 대해 알고있는 지식의 양을 의미
    - 결합도가 높다/낮다, 강하다/느슨하다로 표현
    - 결합도가 낮은 설계 = 훌륭한 설계
- **캡슐화(Encapsulation)**
    - **모듈 내부와 외부를 함께 아우르는 개념**
    - 모듈 내부에 데이터와 메서드를 함께 묶은 후, 오직 외부에 제공된 공용 인터페이스를 통한 접근만 허용하는 방식 (직접적인 접근 제한)
    - 캡슐화 원칙을 지키는 설계 = 훌륭한 설계

올바른 기능을 제공하도록 동작하는 코드를 작성하면서, 내일 좀 더 변경하기 쉬운 코드 배치를 선택해야 함
=> 변경하기 쉽게 코드를 설계해야 함
=> **훌륭한 설계란, 변경하기 쉽게 코드를 배치한 설계**

### 설계의 핵심

- 모든 설계 원칙과 이론은 변경과 관련됨
- ex) SOLID를 구성하는 5가지 설계 원칙은 모듈 안에 포함될 요소와 모듈 사이의 의존성을 통제해서 코드를 변경하기 쉽게 만드는 것을 목표로 함
- ex) 디자인 패턴 역시 특정한 방식으로 변경이 발생할 때 이 변경을 유연하게 수용할 수 있는 코드의 배치 방식을 제시하고 있음
    - 디자인 패턴에서 가장 중요한 부분은 **어떤 변경을 감추기 위해 어떤 디자인 패턴을 사용해야 하는지를 익히는 것**
- 응집도, 결합도, 캡슐화를 더 잘 이해하기 위해서는 **변경의 관점에서 이 원칙들을 이해해야 함**

### 변경을 예상하지 마라

- 변경은 변경이 발생할 때만 변경이라는 사실을 기억하라.
- 막연한 추측만으로 실제로 일어나지도 않은 변경에 대비하기 위해 불필요한 추상화를 추가해서는 안된다
- 변경을 예상해서 코드를 복잡하게 만들면, 코드를 이해하고 수정하는데 필요한 부담이 증가
- **최대한 코드를 단순하게 유지하고 실제로 변경이 발생할 때까지 기다렸다가 꼭 필요한 시점에 추상화를 추가하라**

## 변경 관점에서의 응집도

변경 관점에서의 응집도에 대해 이해하기 위해 절차적인 설계에서의 ReservationService 구현을 다시 살펴보자

```java
public class ReservationService {
    private ScreeningDAO screeningDAO;
    private MovieDAO movieDAO;
    private DiscountPolicyDAO discountPolicyDAO;
    private DiscountConditionDAO discountConditionDAO;
    private ReservationDAO reservationDAO;

    public ReservationService(ScreeningDAO screeningDAO,
                              MovieDAO movieDAO,
                              DiscountPolicyDAO discountPolicyDAO,
                              DiscountConditionDAO discountConditionDAO,
                              ReservationDAO reservationDAO) {
        this.screeningDAO = screeningDAO;
        this.movieDAO = movieDAO;
        this.discountConditionDAO = discountConditionDAO;
        this.discountPolicyDAO = discountPolicyDAO;
        this.reservationDAO = reservationDAO;
    }

    public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {
        // 1. 데이터베이스로부터 필요한 객체 조회(메모리 로드)
        Screening screening = screeningDAO.selectScreening(screeningId);
        Movie movie = movieDAO.selectMovie(screening.getMovieId());
        DiscountPolicy policy = discountPolicyDAO.selectDiscountPolicy(movie.getId());
        List<DiscountCondition> conditions = discountConditionDAO.selectDiscountConditions(policy.getId());

        // 2. 할인 조건을 이용해서 할인 가능 여부 확인 (너무 길어지므로 별도의 메소드로 구현 후 이를 호출하도록 함)
        DiscountCondition condition = findDiscountCondition(screening, conditions);

        // 3.  할인 가능하다면 -> 할인 정책 이용해서 요금 계산 / 할인 안된다면 -> 정가로 요금 계산
        // 마찬가지롤 `calculateDiscount`라는 별도의 메서드를 호출
        Money fee;
        if (condition != null) { // null이 아니라면 할인 가능
            fee = movie.getFee().minus(calculateDiscount(policy, movie));
        } else { // 할인 불가능
            fee = movie.getFee();
        }

        // 4. Reservation 생성 후 데이터베이스에 저장
        Reservation reservation = makeReservation(customerId, screeningId, audienceCount, fee);
        reservationDAO.insert(reservation);

        return reservation;
    }

    // 할인 조건을 이용해서 할인 가능 여부 확인을 위한 메서드

    /**
     * DiscountCondition의 타입이 무엇이고, 타입에 따라 어떤 일을 해야 하는지를
     * DiscountCondition이 아니라, 외부의 ReservationService가 대신 판단하고 결정하고 있음
     * 절차적인 방식으로 작성된 코드에서 흔히 볼 수 있는 사례
     * 객체의 타입을 판단하고, 타입에 따라 어떤 일을 할지를 외부에서 결정하고 있다면? -> 절차적인 방식의 코드
     */
    private DiscountCondition findDiscountCondition(Screening screening, List<DiscountCondition> conditions) {
        // 루프를 돌며 DiscountCondition의 타입이 기간 조건인지 체크하고, 상영 시간을 이용해서 할인 여부 판단
        for (DiscountCondition condition : conditions) {
            if (condition.isPeriodCondition()) { // 기간 조건이라면
                if (screening.isPlayedIn(condition.getDayOfWeek(),
                        condition.getStartTime(),
                        condition.getEndTime())) {
                    return condition;
                }
            } else { // 순서 조건이라면
                if (condition.getSequence().equals(screening.getSequence())) { // 상영의 회차를 이용해서 할인 여부 판단
                    return condition;
                }
            }
        }

        return null;
    }

    // 할인 금액 계산 메서드
    // findDiscountCondition과 유사한 형태
    // DiscountPolicy의 타입을 판단하고 어떤 일을 해야 하는지를 ReservationService가 대신 결정하고 있음
    // 역시 제 3의 객체가 객체의 타입을 판단하고 수행하는 형태 -> 절차적인 방식
    private Money calculateDiscount(DiscountPolicy policy, Movie movie) {
        if (policy.isAmountPolicy()) {
            return policy.getAmount();
        } else if (policy.isPercentPolicy()) {
            return movie.getFee().times(policy.getPercent());
        }

        return Money.ZERO;
    }

    // Reservation 생성 메서드
    private Reservation makeReservation(Long customerId, Long screeningId, Integer audienceCount, Money fee) {
        return new Reservation(customerId, screeningId, audienceCount, fee.times(audienceCount));
    }
}
```

- 절차적인 설계에서의 ReservationService는 내부 모든 로직들이 상영을 예매하는 기능을 구현하는 데에 집중하고 있다.
- 그렇다면 ReservationService는 응집도가 높다고 볼 수 있는 것일까?

응집도의 개념을 '변경 관점'에서 살펴보자

### 응집도 - 변경 관점

- **모듈 내부 요소들이 함께 변경되는 정도**를 의미
- 높은 응집도 - 모듈 전체가 동일한 이유로 변경
- 낮은 응집도 - 모듈 각 부분이 서로 다른 이유로 변경
- **변경의 시점과 속도(빈도)**가 중요
    - **코드가 변경되는 시점과 속도가 동일하다면 변경의 이유가 동일**한 것
    - 모듈 전체의 코드가 동일 시점 동일 속도로 변경된다면 응집도가 높은 모듈 = 모듈 전체가 동일한 이유로 변경

### 절차적인 방식의 ReservationService 분석

- ReservationService의 `calculateDiscount`는 새로운 할인 정책을 추가하거나 할인 정책의 종류별로 할인금을 계산하는 구체적인 방법이 달라질 때 변경됨
- ReservationService의 `findDiscountCondition`은 새로운 할인 조건을 추가하거나 제거할 때, 할인 조건의 종류별로 할인 조건을 판단하는 구체적인 방법이 달라질 때 변경됨
  => ReservationService는 서로 다른 싲머에 서로 다른 속도로 변경되는 2개의 메서드를 함께 포함하고 있음.. => 모듈의 응집도가 낮음

### 객체지향 방식의 코드 분석

- AmountDiscountPolicy는 금액 할인 정책에 따라 할인 금액을 계산하는 방식을 바꿀때만 변경
- PercentDiscountPolicy는 비율 할인 정책에 따라 할인 금액을 계산하는 방식을 바꿀때만 변경
- SequenceCondition은 순번 조건에 따라 할인 여부를 판단하는 방법을 바꿀때만 변경
- PeriodCondition은 기간 조건에 따라 할인 여부를 판단하는 방법을 바꿀때만 변경
  => 각 클래스는 단 하나의 이유 때문에 변경됨
  => 높은 응집도

### SOLID의 단일 책임 원칙(Single Responsibility Principle, SRP)

- 응집도는 SOLID에서 말하는 **단일 책임 원칙과 관련**
- 각 클래스가 단 하나의 변경 이유를 가지도록 만드는 설계 원칙을 단일 책임 원칙이라고 부름
- 단일 책임 원칙은 응집도가 높은 클래스를 만들기 위해서는 **서로 다른 이유로 변경되는 코드를 서로 다른 클래스로 분리해야 한다**는 사실을 강조

### 응집도 - 클래스 크기 기준에 대한 가이드

- 라인 수나 메서드의 개수가 아니라 **변경의 이유를 기준으로 클래스의 크기를 정하라**
- **클래스 안에 변경의 이유가 서로 다른 코드가 존재하면 별도의 클래스로 분리**해라

### 응집도를 높이기 위한 방법

- 클래스 전체가 아니라 일부 메서드의 속성만 변경하고 있다면 응집도가 낮은 것 => **변경의 이유를 기준으로 클래스를 분리**하라
    - 가장 쉬운 방법은 '상속'을 이용하여 클래스를 분리
- 특정한 메서드 그룹이 특정한 속성 그룹만 사용한다면 응집도가 낮은 것 => **함께 사용되는 메서드와 속성을 별도의 클래스로 분리**하라
    - 앞서 분리시킨 로직에서 사용하는 속성을 해당 클래스로 함께 이동시키기 (분리시킨 클래스에서만 사용하는 필드를 파악하기)
- 객체를 생성할 때 모든 속성이 아니라 일부 속성을 null로 설정한다면 응집도가 낮은 것 => **초기화되는 속성의 그룹을 기준으로 클래스를 분리**하라

## 변경 관점에서의 결합도

### 절차적인 방식의 ReservationService - DiscountPolicy 분석 (1)

변경 관점에서의 결합도를 이해하기 위해 절차적인 방식으로 작성된 코드를 살펴보자

```java
public class ReservationService {
    private Money calculateDiscount(DiscountPolicy policy, Movie movie) {
        if (policy.isAmountPolicy()) {
            return policy.getAmount();
        } else if (policy.isPercentPolicy()) {
            return movie.getFee().times(policy.getPercent());
        }

        return Money.ZERO;
    }
}
```

```java
public class DiscountPolicy {
    public enum PolicyType {PERCENT_POLICY, AMOUNT_POLICY}

    private Long id;
    private Long movieId;
    private PolicyType policyType;
    private Money amount;
    private Double percent;

    public DiscountPolicy() {
    }

    public DiscountPolicy(Long movieId, PolicyType policyType, Money amount, Double percent) {
        this(null, movieId, policyType, amount, percent);
    }

    public DiscountPolicy(Long id, Long movieId, PolicyType policyType, Money amount, Double percent) {
        this.id = id;
        this.movieId = movieId;
        this.policyType = policyType;
        this.amount = amount;
        this.percent = percent;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMovieId() {
        return movieId;
    }

    public void setMovieId(Long movieId) {
        this.movieId = movieId;
    }

    public boolean isAmountPolicy() {
        return PolicyType.AMOUNT_POLICY.equals(policyType);
    }

    public boolean isPercentPolicy() {
        return PolicyType.PERCENT_POLICY.equals(policyType);
    }

    public PolicyType getPolicyType() {
        return policyType;
    }

    public void setPolicyType(PolicyType policyType) {
        this.policyType = policyType;
    }

    public Money getAmount() {
        return amount;
    }

    public void setAmount(Money amount) {
        this.amount = amount;
    }

    public Double getPercent() {
        return percent;
    }

    public void setPercent(Double percent) {
        this.percent = percent;
    }

}
```

- ReservationService는 DiscountPolicy에 의존
- ReservationService의 DiscountPolicy에 대한 지식의 양
    - 클래스 이름에 의존 (DiscountPolicy를 직접 참조)
    - 메서드 시그니처에 의존 (getter를 사용)

### 객체지향 설계에서의 Movie - DiscountPolicy 분석 (1)

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }
}
```

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    public DiscountPolicy(DiscountCondition... conditions) {
        this.conditions = List.of(conditions);
    }

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

- Movie는 DiscountPolicy에 의존
- Movie의 DiscountPolicy에 대한 지식의 양
    - 클래스 이름에 의존 (DisocuntPolicy 직접 참조)
    - 메서드 시그니처에 의존(calculateDiscount 사용)


- 두 방식 모두 DiscountPolicy의 클래스명과 메서드 시그니처에 대한 지식만 보유 중
- 그렇다면 동일한 결합도를 갖는다고 볼 수 있을까?

### 결합도(Coupling) - 변경 관점

- 외부의 다른 모듈에 의해 함께 변경되는 정도
    - 결합도가 높다 = 외부의 모듈 변경시 함께 변경되는 빈도가 많다
    - 결합도가 낮다 = 외부의 모듈 변경시 함께 변경되는 빈도가 적다
- 의존성과 결합도는 밀접한 연관
    - 의존성: **외부의 모듈이 변경될 때 함께 변경될 수 있는 가능성**을 의미
    - 의존성은 있다/없다의 개념
    - 의존성이 항상 함께 변경된다는 의미 X
- 결합도는 의존성이 존재한다는 전제하에서 변경에 의한 영향의 정도를 표현
    - 결합도: **함께 변경되는 빈도**를 의미
    - 결합도는 빈번하다/드물다의 개념
    - 결합도는 상대적인 개념
    - ex) B가 10번 변경될 때 A가 3번 변경 = 낮은 결합도
    - ex) B가 10번 변경될 때 A가 7번 변경 = 높은 결합도 (더 빈번하게 변경)

### 결합도 낮추기

- 좋은 설계 = 낮은 결합도 = 변경 가능성이 낮은 설계 -> **설계 개선을 위해서는 함께 변경될 가능성을 낮추어야 함**
- 의존성을 제어하는 이유: 결합도를 낮춰서 함께 변경되는 빈도를 줄이기 위함
- 결합도를 낮추기 위해서는 **자주 변하지 않는 안정적인 부분에 의존하도록 의존성을 제어해야 함**
- **A가 B의 '자주 변하지 않는 부분에만 의존'한다면**, 함께 변경될 가능성을 낮출 수 있음

### 의존성 제어 원칙

**상대적으로 안정적인 부분에 의존하도록 만드려면?**

- 먼저, **자주 변하는 부분과 상대적으로 변하는 빈도가 적은 부분을 분리**해야 함
- 이후, 자주 변하지 않는 부분에 의존하도록 의존성을 제어
- **자주 변하지 않는 안정적인 부분** => **'추상화'**라고 부름
- **자주 변하는 불안정한 부분** => **'구현'**이라고 부름
- => '자주 변하는 부분과 자주 변하지 않는 부분의 분리' = **'구현과 추상화의 분리'**
- => 구현이 아닌 추상화에 의존하도록 변경

- **모듈 내부의 구현을 변경했을 때, 외부의 모듈이 영향을 받는다? => 결합도가 높다**
- **모듈 내부의 구현을 변경했을 때, 외부의 모듈이 영향을 받지 않는다? => 결합도가 낮다**

### 인터페이스

- **협력이라는 문맥에서의 추상화 = 인터페이스**
- 협력 관점에서 **추상화와 구현의 분리 = 인터페이스와 구현의 분리 원칙**
- => 결합도를 낮추기 위해 구현이 아닌 인터페이스에 의존하도록 만들어야 함
- => 구현이 아닌 **인터페이스에 대해 프로그래밍 해야 함**

- 일반적으로 클래스 안에 정의된 **필드는 '구현'에 해당**(자주 변경됨)
    - 자주 변경되는 부분은 외부에서 접근할 수 없도록 캡슐화 필요 => `private` 접근 제어자
- **getter/setter**는 외부에서 접근 가능해야 하므로 **'인터페이스'에 해당**
    - `public` 접근 제어자
    - 실제로는 구현에 속하지만, 일단은 인터페이스..
- **메서드 내부에 포함된 로직**은 외부에 영향을 주지 않고 변경할 수 있어야 하므로 **'구현'에 해당**
    - `private` 접근 제어자

### 절차적인 방식의 ReservationService - DiscountPolicy 분석 (2)

- ReservationService는 DiscountPolicy의 getter와 setter로 호출 => 인터페이스에 의존?
- 구현에 속하는 필드의 타입을 변경한다고 가정
    - 필드는 구현에 해당하므로 타입을 변경하더라도 인터페이스가 변경이 전파되는 것을 막아주어야 함
    - 하지만, getter/setter는 필드의 이름과 타입을 기반으로 구현되어 있어서 필드의 타입이 변경되면 getter/setter의 시그니처도 변경해야 함
    - 결과적으로, **`getPercent()`에 의존하는 `calculateDiscount` 메서드는 반환 타입이 변경되었기 때문에 코드를 수정해야 함..**
- 구현에 해당하는 필드를 변경했는데도, getter/setter를 함께 변경해야 했음 => **getter/setter는 내부 구현 변경 시 함께 변경되므로 인터페이스가 아니라 '구현'에 속함**
    - 사실 DiscountPolish의 모든 getter/setter는 **모든 필드의 이름과 타입을 외부에 그대로 노출하므로 '구현'에 속함**
- => **ReservationService는 DiscountPolicy의 '구현'에 의존하고 있음**
- => 결합도가 높음

### 객체지향 설계에서의 Movie - DiscountPolicy 분석 (2)

- DiscountPolicy의 conditions 필드 & PercentDiscountPolicy의 percent 필드는 '구현'에 속함 -> `private`
- DisconutPolicy의 `calculateDiscount` 메서드 & `getDiscountAmount` 메서드는 '인터페이스'에 속함 -> 외부 접근 가능해야 하므로 `public`, 자식 클래스에서 접근
  가능해야 하므로 `protected`
- PercentDiscountPolish 클래스의 `getDiscountAmount`는 부모가 메시지를 전송하기 위해 사용하므로 '인터페이스'에 속함
- 각 메서드의 구현부는 '구현'에 속함

- 현재 **Movie는 DiscountPolicy의 인터페이스에 의존 중**
- => DiscountPolicy의 내부 구현이 변경되더라도 Movie가 영향 받아서는 안됨
- DiscountPolicy의 conditions 필드의 타입을 List에서 Set으로 변경한다고 가정
    - conditions를 사용하는 메서드의 구현부도 함께 수정
    - 객체지향적으로 설계한 DiscountPolicy에서는 **conditions가 `calculateDiscount` 메서드 내부에서만 사용**되기 때문에 필드의 타입을 변경하더라도, **외부로 영향 파급 X
      **
    - **DiscountPolicy의 calculateDiscount의 시그니처가 변경되지 않는 한, Movie의 코드는 변경되지 않음**

- 이는 객체지향 설계 시, 행동을 먼저 결정하고 이후 필요한 데이터를 결정했기에 당연한 것
    - Movie와 DiscountPolicy 사이의 협력을 설계할 때는 conditions의 존재 자체를 몰랐기 때문에, Movie는 conditions에 의존할 수가 없음

=> 객체지향 설계의 결합도가 낮은 이유는 **협력에 필요한 메시지를 먼저 결정하기 때문에 처음부터 내부 구현에 대한 의존성을 끊을 수 있기 때문**

### 정리

- 결합도가 변경의 빈도와 관련이 있음
- 결합도를 낮추기 위해서는 인터페이스(추상화)와 구현을 분리하고 인터페이스에 의존하도록 코드를 배치해야 함
- 인터페이스에 의존함으로써 내부 구현에 대한 의존성을 끊을 수 있음

## 캡슐화

### 절차적인 방식의 DiscountPolicy

```java
public class DiscountPolicy {
    public enum PolicyType {PERCENT_POLICY, AMOUNT_POLICY}

    private Long id;
    private Long movieId;
    private PolicyType policyType;
    private Money amount;
    private Double percent;

    public DiscountPolicy() {
    }

    public DiscountPolicy(Long movieId, PolicyType policyType, Money amount, Double percent) {
        this(null, movieId, policyType, amount, percent);
    }

    public DiscountPolicy(Long id, Long movieId, PolicyType policyType, Money amount, Double percent) {
        this.id = id;
        this.movieId = movieId;
        this.policyType = policyType;
        this.amount = amount;
        this.percent = percent;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getMovieId() {
        return movieId;
    }

    public void setMovieId(Long movieId) {
        this.movieId = movieId;
    }

    public boolean isAmountPolicy() {
        return PolicyType.AMOUNT_POLICY.equals(policyType);
    }

    public boolean isPercentPolicy() {
        return PolicyType.PERCENT_POLICY.equals(policyType);
    }

    public PolicyType getPolicyType() {
        return policyType;
    }

    public void setPolicyType(PolicyType policyType) {
        this.policyType = policyType;
    }

    public Money getAmount() {
        return amount;
    }

    public void setAmount(Money amount) {
        this.amount = amount;
    }

    public Double getPercent() {
        return percent;
    }

    public void setPercent(Double percent) {
        this.percent = percent;
    }

}
```

- 데이터와 메서드를 클래스 내부에 함께 포함 -> 전통적인 관점에서의 캡슐화를 준수하는 것처럼 보임

### 객체지향적인 방식에서의 DiscountPolicy

```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    public DiscountPolicy(DiscountCondition... conditions) {
        this.conditions = List.of(conditions);
    }

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

- 마찬가지로 데이터와 메서드를 클래스 내부에 함께 포함 -> 전통적인 관점에서의 캡슐화를 준수하는 것처럼 보임

- 그렇다면 두 방식은 동일한 수준의 캡슐화를 제공하는 것일까?

### 캡슐화(Encapsulation) - 변경 관점

- 변하는 부분을 내부로 숨기는 추상화 기법을 의미
- 변하는 부분과 변하지 않는 부분을 식별한 후, 변하는 부분을 안정적인 부분 뒤로 감추는 기법
- 낮은 결합도를 얻기 위해서는 안정적인 추상화에 의존하도록 의존성을 통제해야 함 -> 캘슐화는 낮은 결합도라는 목표를 달성하기 위한 기반을 제공

### 인터페이스와 구현의 분리

- 인터페이스 뒤로 불안정하게 변하는 구현을 감춤으로써 변하는 부분을 캡슐화할 수 있는 프로그래밍 원칙
- 외부에서는 구현이 보이지 않기 때문에 인터페이스에 의존할 수밖에 없게 됨
- 인터페이스가 구현의 변경으로 인한 여파를 막아주기 때문에 두 클래스 사이의 결합도는 자연스럽게 낮아짐

### 전통적인 캡슐화 = 데이터 캡슐화(Data Encapsulation)

- 데이터를 숨기고 공용 인터페이스를 제공하는 **전통적인 관점에서의 캡슐화 = 캡슐화의 한 종류인 '데이터 캡슐화'**
- 절차적인 설계에서는 **데이터 수정 시 데이터를 사용하는 프로세스가 변경**됨 -> **데이터 캡슐화 실패**
- 객체지향 설계에서는 메시지를 먼저 결정한 후 데이터가 아닌 인터페이스에 의존 -> **데이터 캡슐화 성공**

### 캡슐화 해석

- ??? 캡슐화 = ???의 변경을 외부에 감춘다는 의미
    - **데이터 캡슐화** = 데이터의 변경을 외부에 감춤
    - **타입 캡슐화** = 타입의 변경을 외부에 감춤 (가장 중요)

### 타입 캡슐화 = 의존성 역전 원칙(Dependency Inversion Principle, DIP)

- Movie가 **인터페이스(추상화)인 DiscountPolicy에만 의존**하기 때문에 Movie 입장에서 DiscountPolicy의 **자식 클래스들의 구체적인 타입이 숨겨짐**
    - => 새로운 타입을 추가하더라도 Movie의 코드 수정 필요 X
- 확장되는 타입인 AmountDiscountPolicy와 PercentDiscountPolicy 역시 추상화인 DiscountPolicy에만 의존

- 상위 모듈인 Movie와 하위 모듈인 AmountDiscountPolicy && PercentDiscountPolicy은 모두 추상화(인터페이스)인 DiscountPolicy에만 의존하고 있음
- => **상위 모듈과 하위 모듈 모두 추상화에 의존하도록 코드를 배치하는 원칙** = **의존성 역전 원칙(Dependency Inversion Principle, DIP)**
- 의존성 역전 원칙은 추상화를 기준으로 타입을 캡슐화하기 위한 기반 구조를 제공

### 의존성 주입과 리스코프 치환 원칙(Liskov Substitution Principle, LSP)

- 타입을 캡슐화 한 후, 즉 의존성 역전 원칙을 준수한 후에는 **컴파일 타임에 의존하는 추상화를 런타임에 의존해야 하는 구체적인 타입으로 대체할 수 있어야 함**
- => Movie가 의존하느 추상 클래스인 DiscountPolicy 타입을 전달받는 **생성자를 추가 후, 외부에서 의존성을 주입**할 수 있도록 해야 함
- Movie 입장에서 AmountDiscountPolicy && PercentDiscountPolicy는 DiscountPolicy와 동일하게 취급됨 = 대체 가능함
- => **클라이언트 입자에서 서브 타입이 슈퍼 타입을 대체할 수 있도록 설계하는 원칙 = 리스코프 치환 원칙(Liskov Substitution Principle, LSP)**
- 리스코프 치환 원칙은 타입을 캡슐화 할 수 있는 **타입 계층을 설계하기 위한 원칙**

### 개방-폐쇄 원칙(Open-Closed Principle, OCP)

- 메시지와 메서드를 분리하고, 의존성 역전 원칙과 리스코프 치환 원칙을 적용하면 기존 코드 수정 없이 할인 정책의 타입을 추가할 수 있음
- => **새로운 동작을 추가하면서도 기존 코드는 수정하지 않는 원칙 = 개방-폐쇄 원칙(Open-Closed Principle, OCP)**
- 이 원칙에 따라 작성된 코드는 확장에는 열려있고 수정에는 닫혀있음
- => OCP는 타입 캡슐화를 통해 기존 코드의 수정 없이 타입을 확장할 수 있도록 코드를 배치하는 원칙

## 설계 평가하기

- 응집도, 결합도, 캡슐화는 설계의 품질을 평가하는데 적용할 수 있는 기준을 제공함
- 코드가 복잡해졌다고 느껴지는 순간부터 코드를 검토해보는 것이 좋음

### 응집도 관점에서 설계 평가하기

1. 복잡하다고 생각되는 클래스가 있다면, 이를 **변경의 이유에 따라 나눠보기**

- 즉, 어떤 경우에 해당 코드가 변경되는지르 생각해보기
- 만약 하나의 클래스가 여러가지 이유로 변경될 수 있다면? => 낮은 응집도

2. 응집도를 높이는 방법 적용! (위에서 설명했음)
    - 서로 다른 이유로 변경되는 코드를 분리할 때 사용할 수있는 가장 간단한 방법 = 상속
    - 상속에서는 **변경의 이유에 따라 코드를 자식 클래스와 부모 클래스로 분리**
    - 상속을 이용하면 자주 변하는 것과 변하지 않는 것을 부모 클래스와 자식 클래스로 분리 가능
    - => **응집도 높은 설계를 위해 상속**을 이용 가능

### 결합와 캡슐화 관점에서 설계 평가하기

- 상속 개념에서 상위 정책을 구현하는 상위 클래스와 하위 정책을 구현하는 하위 클래스는 모두 **'추상 메서드'에 의존**
    - => 의존성 역전 원칙 만족 => 결합도 낮음
- 하위 클래스는 상위 클래스를 대체할 수 있음
    - => 리스코프 치환 원칙 만족
- 상위 클래스 수정 없이 하위 클래스를 추가하면 새로운 정책 추가 가능
    - => 개방 폐쇄 원칙 만족

=> 상속을 적용한 설계는 응집도, 결합도, 캡슐화 측면에서 만족할만한 결과를 제공

### 상속이 가지는 한계

- 상속이 가지는 근본적인 한계로 인해 결합도가 높아지고, 캘슐화 원칙이 위반되는 경우도 있음

1. **하위 클래스가 상위 클래스의 필드에 접근하고 있는 경우**

- 상위 클래스의 필드가 수정되면 자식 클래스에 영향
- => 상위 클래스는 자신의 데이터를 온전히 캡슐화하고 있지 않음

2. **하위 클래스가 상위 클래스의 구현에 강하게 결합됨**

- 런타임의 할인 정책을 변경해야 하는 경우처럼 상속을 이용하는 현재 구조는 문제를 복잡하게 만듦
- ex) 하위클래스인 AmountDiscountMovie를 PercentDiscountMovie로 변경해야 한다면? => 새로운 Movie를 또 만들어야 함

### 상속에서 합성으로

- 결합도와 캡슐화가 문제가 된다면 상속을 합성을 변경하는 것이 좋음
- 상속이 할인 정책과 관련된 코드를 Movie의 자식 클래스에 배치하는 방식이라면,
    - ex) Movie (AmountDiscountMovie, PercentDiscountMovie) --> DiscountCondition (SequenceCondition, PeriodCondition)
- 합성은 할인 정책과 관련된 로직을 클래스 계층으로 분리하고 상위 클래스에서 참조하는 방식
    - ex) Movie --> DiscountPolicy (AmountDiscountPolicy, PercentDiscountPolicy) --> DiscountCondition (
      SequenceCondition, PeriodCondition)
    - Movie와 DiscountPolicy 사이의 관계가 '합성'

--- 

## 중복 할인 정책 추가하기

사용자에게 더 많은 헤택을 제공하기 위해 **하나의 영화에 다수의 할인 정책을 설정할 수 있도록 바뀌었다고 가정** = 중복 할인 정책

### 절차적인 방식에서의 중복 할인 정책 추가

```java
public class ReservationService {
    private ScreeningDAO screeningDAO;
    private MovieDAO movieDAO;
    private DiscountPolicyDAO discountPolicyDAO;
    private DiscountConditionDAO discountConditionDAO;
    private ReservationDAO reservationDAO;

    public ReservationService(ScreeningDAO screeningDAO,
                              MovieDAO movieDAO,
                              DiscountPolicyDAO discountPolicyDAO,
                              DiscountConditionDAO discountConditionDAO,
                              ReservationDAO reservationDAO) {
        this.screeningDAO = screeningDAO;
        this.movieDAO = movieDAO;
        this.discountConditionDAO = discountConditionDAO;
        this.discountPolicyDAO = discountPolicyDAO;
        this.reservationDAO = reservationDAO;
    }

    public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {
        Screening screening = screeningDAO.selectScreening(screeningId);
        Movie movie = movieDAO.selectMovie(screening.getMovieId());
        // List<DiscountPolicy>를 조회하도록 데이터베이스 조회 로직 수정
        List<DiscountPolicy> policies = discountPolicyDAO.selectDiscountPolicy(movie.getId());
        List<DiscountCondition> conditions = discountConditionDAO.selectDiscountConditions(policy.getId());

        DiscountCondition condition = findDiscountCondition(screening, conditions);

        Money fee;
        if (condition != null) {
            // calculateDiscount 호출 시 policies 전달
            fee = movie.getFee().minus(calculateDiscount(policies, movie));
        } else {
            fee = movie.getFee();
        }

        Reservation reservation = makeReservation(customerId, screeningId, audienceCount, fee);
        reservationDAO.insert(reservation);

        return reservation;
    }

    private DiscountCondition findDiscountCondition(Screening screening, List<DiscountCondition> conditions) {
        for (DiscountCondition condition : conditions) {
            if (condition.isPeriodCondition()) {
                if (screening.isPlayedIn(condition.getDayOfWeek(),
                        condition.getStartTime(),
                        condition.getEndTime())) {
                    return condition;
                }
            } else { // 순서 조건이라면
                if (condition.getSequence().equals(screening.getSequence())) { // 상영의 회차를 이용해서 할인 여부 판단
                    return condition;
                }
            }
        }

        return null;
    }

    // 할인 정책이 여러 개이기 때문에 List<DiscountPolicy>를 받도록 수정 
    private Money calculateDiscount(List<DiscountPolicy> policy, Movie movie) {
        if (policy.isAmountPolicy()) {
            return policy.getAmount();
        } else if (policy.isPercentPolicy()) {
            return movie.getFee().times(policy.getPercent());
        }

        return Money.ZERO;
    }

    private Reservation makeReservation(Long customerId, Long screeningId, Integer audienceCount, Money fee) {
        return new Reservation(customerId, screeningId, audienceCount, fee.times(audienceCount));
    }
}
```

- **기능 확장을 위해 기존 코드를 수정해야 함..**
    - 수정할 코드를 찾기도 어려움
    - 수정할 부분과 상관이 없는 코드로 변경의 영역이 전파되어 버그 발생 확률 증가
- **큰 클래스는 테스트 하기 어려움**
    - 큰 클래스는 응집도가 낮아 현재 수정 중인 부분과 상관이 없는 코드까지도 함께 테스트해야 함
- **중복 할인이라는 중요한 개념도 명확히 표현 X**
    - 중복 할인이라는 갠며을 알고리즘으로 풀고 있음
    - 코드를 읽고 이해한 후, 이해한 알고리즘을 머릿속에서 중복할인이라는 개념과 연결해야 함..
- 현재 코드는 응집도가 낮아서 읽기 어렵고, 이해하기 어렵고, 수정하기도 어려움

### 객체지향 방식에서의 중복 할인 정책 추가

- Movie는 하나 이상의 DiscountPolicy 인스턴스에게 `calculateDiscount` 메시지를 전송할 수 있어야 함
- 중복 할인 정책에서 우리가 감추가 싶은 부분은 **'영화와 협력할 객체의 개수'**
    - => 개수 캡슐화
    - 변하는 부분은 Movie와 협력할 DiscountPolicy의 개수이므로, 이를 캡슐화할 수 있다면 코드 수정 용이
- 이미 Movie는 `calculateDiscount` 메시지를 처리할 수 있는 어떤 DiscountPolicy와도 협력 가능
    - => 런타임에 DiscountPolicy를 대체할 수 있는 어떤 객체든 협력 가능
    - => **여러 개의 할인 정책을 묶은 객체를 이용해 DiscountPolicy를 대체**할 수 있다면 Movie가 DiscountPolicy의 개수를 모른 상태에서도 협력할 수 있도록 만들 수 있음
    - => DisocuntPolicy의 개수 캡슐화 가능

이때 사용할 수 있는 디자인 패턴이 Composite 디자인 패턴

### Composite 디자인 패턴

- 협력하는 객체의 개수를 캡슐화할 때 사용할 수 있는 디자인 패턴
- 다수의 DiscountPolicy 인스턴스를 포함하는 객체를 추가해서 Movie와 협력할 수 있도록 만들어 객체의 개수를 캡슐화

```java
public class OverlappedDiscountPolicy extends DiscountPolicy {
    private List<DiscountPolicy> policies = new ArrayList<>();

    public OverlappedDiscountPolicy(DiscountPolicy... policies) {
        super((screening -> true));
        this.policies = Arrays.asList(policies);
    }

    @Override
    protected Money getDiscountAmount(Screening screening) {
        Money result = Money.ZERO;

        for (DiscountPolicy each : policies) {
            result = result.plus(each.calculateDiscount(screening));
        }

        return result;
    }
}
```

```java

@Test
public void 중복할인정책_계산하기() {
    // given
    Movie movie = new Movie(
            "한산",
            Money.wons(10_000L),
            new OverlappedDiscountPolicy(
                    new PercentDiscountPolicy(
                            0.1,
                            new SequenceCondition(1),
                            new SequenceCondition(3),
                            new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(12, 10))),
                    new AmountDiscountPolicy(
                            Money.wons(1000L),
                            new SequenceCondition(1),
                            new SequenceCondition(3),
                            new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(12, 10)))));

    Screening screening = new Screening(movie, 1, LocalDateTime.of(2024, 12, 11, 18, 0));

    // when
    Money fee = movie.calculateFee(screening);

    // then
    assertEquals(Money.wons(8000L), fee);
}
```

- 기존 코드를 수정하지 않고 기능 확장 가능 => 개방-폐쇄 원칙 만족
- 개념을 명시적으로 표현
- 수정할 코드 찾기 쉬움