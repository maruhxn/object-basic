# 객체지향 구현 (영화 예매 시스템)

## 객체 구현하기

객체지향 설계 순서를 다시 한번 살펴보자

1. 협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하라
2. 객체의 행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 할당하라

이전까지는 행동 결정 후 객체를 선택하는 방법을 다뤘다면,
이번에는 **행동과 데이터를 이용해서 클래스를 구현**해보자

### 상영 구현하기 (영화 예매 책임 구현)
- 상영은 영화를 예매할 수 있다 = 내부적으로 예매(Reservation) 객체를 생성한다
- 예매 객체 생성을 위해서는 **영화의 가격이 필요한데, 응집도 관점에서 상영이 직접 계산하는 것보다는 영화에게 가격 계산을 요청**하는 것이 좋다
- => 상영(`Screening`)은 가격 계산을 위해 영화(`Movie`)와 협력해야 한다

```java
public class Screening {
    // reserve 메서드 구현 시 movie가 필요하므로 추가
    private Movie movie;

    // 먼저 구현
    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }
}
```

### 영화 구현하기 (영화에 할당된 가격을 계산하는 책임 구현)
- 영화를 구현할 클래스인 Movie와 가격을 계산하는 책임을 구현할 메서드인 `calculateFee`의 시그니처는 Screening을 구현하면서 이미 결정되었다
- 따라서, Movie 클래스를 생성하고 그 안에 `calculateFee` 메서드를 추가하자

```java
// 먼저 메서드 추가
public class Movie {

    public Money calculateFee(Screening screening) {
    }
}
```

- **영화는 할인 금액을 게산하기 위해 할인 정책에게 할인 요금을 계산할 것을 요청**한다
- => 영화는 할인 정책과 협력 (응집도 관점)
- Movie 클래스는 할인금액을 게산하기 위해 할인 정책인 DiscountPolicy에게 `calculateDiscount` 메시지를 전송하고, 반환된 할인 금액을 영화의 정가인 `fee`에서 차감한다
- => 영화의 정가를 저장할 `fee`와 할인 금액을 계산할 `discountPolicy`가 필드로 필요하므로 추가하자

```java
// 이후 구현하면서 필드 추가
public class Movie {
    private Money fee; // 영화의 정가
    private DiscountPolicy discountPolicy; // 할인 금액을 계산할 할인 정책

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }
}
```

### 다형성 패턴 적용 - 할인 정책에 할당된 할인 금액을 계산하는 책임 구현
- 영화와 할인 사이의 협력을 설계할 때 코드를 변경하기 쉽게 만들기 위해 **다형성 패턴을 적용**했었음
  - 영화는 할인을 계산하라는 '다형적인 메시지'를 전송하고,
  - 실제로 메시지를 수신하는 객체의 타입이 비율 할인 정책인지, 금액 할인 정책이닞에 따라 적절한 메서드가 실행되도록 협력을 설계했음 (변경 보호 패턴 적용)
- 영화는 추상화인 할인 정책(`DiscountPolicy`)에 대해서만 의존하고, 비율 할인 정책이나 금액 할인 정책에 대해서는 알지 못함
  - **할인 정책(`DiscountPolicy`)은 여러 객체에 의해 대체될 수 있으므로 '역할(Role)'**임
  - 다형성 패턴 + 변경 보호 패턴의 적용 = 추상화의 도입 = '역할' 추가

- **역할을 구현하는 방법**
  - 하나의 객체만 표현한다면 -> **구체 클래스**를 이용해 구현
  - 여러 객체에 의해 대체될 수 있고 **코드를 공유해야 한다면** -> **추상 클래스**를 이용해서 구현
  - 코드를 공유할 필요도 없고, **결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원한다면** -> **인터페이스**를 통해 구현
- 여기서는 데이터 로직을 공유해야 하므로 추상 클래스를 통해 DiscountPolicy를 구현

```java
// DiscountPolicy - 추상 클래스
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    // 추상 클래스로 선언했음에 주목하자
    // 자식 클래스(금액 할인 정책, 비율 할인 정책)은 이 메서드를 오버라이딩 해서 자신만의 방법으로 할인 금액을 계산 가능
    abstract protected Money getDiscountAmount(Screening screening);
}
```

```java
// AmountDiscountPolicy - 자식 클래스
public class AmountDiscountPolicy extends DiscountPolicy {
    private Money discountAmount;

    // 오버라이딩
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}
```

```java
// PercentDiscountPolicy - 자식 클래스
public class PercentDiscountPolicy extends DiscountPolicy {
    private double percent;

    // 오버라이딩 (주목)
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getFixedFee().times(percent);
    }
}
```

- 협력을 통해 현재 객체가 할 수 없는 일을 다른 객체에게 요청함으로써 더 큰 작업 수행
    - PercentDiscountPolicy의 `getDiscountAmount`에서 영화의 정가는 Screening의 `getFixedFee()` 메서드를 통해 얻어옴
        - Screening은 Movie를 알고 있고, Movie는 영화의 정가를 알고있으므로 Screening을 통해 가져오는 것
    - 따로 DiscountPolicy에 Movie 필드를 추가하지 않고 기존에 알고있는 정보를 통해 해결

```java
// Screening에 getFixedFee() 추가
public class Screening {
    private Movie movie;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    // 추가
    public Money getFixedFee() {
        return movie.getFee();
    }
}
```

```java
// Movie에 getFee() 추가
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    // 추가
    public Money getFee() {
        return fee;
    }
}
```

- 절차적인 방식의 Movie는 사용되는 문맥을 모르는 상태에서 추측에 기반해 getter/setter를 추가했음
- 반면, 객체지향 방식의 Movie는 협력을 설계하는 과정에서 **할당된 책임에 기반하여 꼭 필요한 경우에만 메서드를 추가**했음
- => 변경에 있어서 더 유리함

### 할인 조건 구현
- 할인 조건도 할인 정책처럼 다형적인 메시지를 추상화에 전송하고, 메시지를 수신한 객체가 자신의 타입에 기반해서 적합한 행동을 수행
- 앞서, DiscountPolicy의 `calculateDiscount` 메서드에서 할인 여부를 판단하기 위해 DiscountCondition에게 `isSatisfiedBy` 메시지를 전송했음
  - 할인 조건의 타입은 하나가 아니기 때문에 이 `isSatisfiedBy` 메시지를 수신할 DiscountCondition 인스턴스는 자신에게 적합한 행동을 선택해야 함
  - 기간 조건과 순서 조건은 로직이나 데이터를 공유할 필요가 없음 => 결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원함 => **인터페이스로 정의**

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```

- SequenceCondition은 Screening에게 회차가 동일한지를 비교하는 `isSequence` 메시지를 전송
  - Screening이 협력에 참여하기 위해 `isSequence` 메서드 구현 필요

```java
// SequenceCondition의 isSatisfiedBy 구현 및 데이터 추가
public class SequenceCondition implements DiscountCondition {
    private int sequence;

    @Override
    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}
```

```java
// Screening에 isSequence 메서드 구현 추가
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    public Money getFixedFee() {
        return movie.getFee();
    }

    // 추가
    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }
}
```

- PeriodCondition은 Screening의 상영 시작 시간이 조건에 명시된 요일과 동일하고 시간 범위에 포함되는지 확인
  - 이를 위해 dayOfWeek, startTime, endTime 필드를 추가하고, 이 필드를 이용해서 할인 여부를 판단하도록 구현
  - Screening의 `getStartTime` 메시지 전송 -> Screening이 협력에 참여하기 위해 `getStartTime` 추가

```java
// isSatisfiedBy 구현 & 데이터 필드 추가
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime, endTime;

    public boolean isSatisfiedBy(Screening screening) {
        return  screening.getStartTime()
                .getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo( screening.getStartTime()
                        .toLocalTime()) >= 0;
    }
}
```

```java
// getStartTime() 추가
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    public Money getFixedFee() {
        return movie.getFee();
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    // 추가
    public LocalDateTime getStartTime() {
        return whenScreened;
    }
}
```

### 클래스 구조와 도메인 개념 구조 비교

이렇게 완성된 **클래스의 구조는 도메인 개념의 구조와 거의 유사**하다.
두 구조가 유사한 형태를 띠는 것은 우연이 아니라 예매 기능을 구현할 때 **도메인 모델 안에 포함된 개념과 관계에 기반해서 책임을 할당할 대체를 선택했기 때문**

이렇게 코드를 도메인과 유사한 형태로 설계하는 이유? => **표현적 차이를 줄이기 위해**
표현적 차이를 줄이는 이유? => 코드가 도메인과 유사하면 **요구사항 변경 시 수정할 코드를 찾기 쉬움**

### 위임식(delegated) / 분산식(dispersed) 제어 스타일

- 절차적인 방식 -> 모든 제어가 프로세스를 구현한 코드로 집중되었음
- 객체지향 방식 -> 제엉가 여러 객체 사이로 분배됨
  - **객체지향 애플리케이션은 스스로를 책임지는 자율적인 객체들로 구성**되기 때문
  - **객체는 자신이 할수 없는 일을 다른 객체에게 위임**
  - => 제어 분산
  - => 수정하기 쉽고 더 유연한 설계

---

## 메시지와 메서드의 분리

객체를 이용해서 애플리케이션을 설계하기 위해서는 **메시지와 메서드의 개념**을 이해하는 것이 중요

### 메시지(message)와 메서드(method)
- 메시지: 한 객체가 다른 객체와 의사소통할 수 있는 유일한 방법
- 메서드: 메시지를 수신한 객체가 메시지를 처리하기 위해 수행하는 행동
    - **동일한 메시지를 전송하더라도, 메시지를 수신한 객체는 자신의 타입에 맞는 적절한 메서드를 선택한 후 실행 가능**

### 메시지와 메서드의 분리는 다형성의 기반

- **다형성**은 **메시지와 메서드를 분리**하고 **런타임에 이들을 조합**해서 다양한 종류의 객체들이 협력할 수 있도록 구성하는 객체지향만의 독특한 매커니즘에 기반함
- 이렇게 복잡한 과정을 거치면서까지 메시지와 메서드를 분리해야 하는 이유가 뭘까?
  - => 의존성을 제어해서 내부의 데이터가 변경되거나 타입이 바뀔 때의 파급효과를 제어하기 위해서 
  - => 즉, **수정하기 쉬운 코드를 작성하기 위해**

- 메시지와 메서드를 분리하면 클라이언트는 메시지에만 의존하기 때문에 메시지를 처리할 수 있는 어떤 객체와도 협력 가능
- => 즉, **클라이언트의 코드 수정 없이 협력할 객체 타입을 쉽게 변경** 가능
- => 단순히 협력할 객체를 새롭게 구현하고 이로 갈아끼워주기만 하면 됨

### 메시지를 먼저 결정

- 변경하기 쉬운 구조 설계를 위해서는 **메시지를 먼저 결정하고 이를 수신할 객체를 나중에 선택**
- 이는 객체지향 설계 원칙에서 '행동 먼저 결정, 적합한 객체 나중에 선택'과 동일
  - '다른 객체가 행동하도록 전송하는 요청 = 메시지'이기 때문
- 자바와 같은 강타입 언어에서는 메시지만 단독으로 사용할 수 없고, 대신 **메시지를 포함한 명확한 타입을 정의해야 함**
  - => 예제에서 `isSatisfiedBy` 메시지를 정의하기 위해 `DiscountCondition`이라는 인터페이스를 정의한 이유
  - DiscountCondition 인터페이스를 구현한 객체는 이 협력에 참여 가능
- **DiscountPolicy가 메시지에만 의존**하고 있기 때문에 **새로운 타입의 할인 조건을 추가하더라도 DiscountPolicy는 수정할 필요가 없음**

### 동적 바인딩

*DiscountPolicy가 DiscountCondition 인터페이스에만 의존하는데도 런타임에 Sequenceondition과 PeriodCondition의 메서드를 어떻게 실행 가능할까?*

- 객체지향에서는 실행될 메서드가 **런타임에 결정**되기 때문
- 런타임에서 어떤 클래스가 인터페이스를 대체하는지에 따라 서로 다른 메서드가 실행됨
- 이처럼, **런타임의 객체가 메시지를 처리하기에 적절한 클래스와 메서드를 결정하는 방식** => **동적 바인딩**

### 객체지향의 기반은 자율적인 객체

- 객체는 자기 자신을 스스로 책임져야 하기 때문에, **메시지를 수신했을 때 자기 자신이 어떤 일을 해야 하는지 스스로 결정**
- 동적 바인딩은 객체가 자율적이어야 한다는 객체지향의 철학을 뒷받침함

---

## 유연하고 일관적인 협력

### 남아있는 문제: 컴파일 타임 의존성과 런타임 의존성

- 코드 레벨에서 DiscountPolicy는 오직 DiscountCondition 인터페이스에만 의존
- 하지만, 런타임에는 DiscountPolicy 객체가 SequenceCondition과 PeriodCondition 객체에게 메시지를 전송할 수 있어야 함
- => **컴파일 타임 의존성과 런타임 의존성이 서로 다름**

이를 해결하기 위해서는 외부의 객체가 SequenceCondition 인스턴스나 PeriodCondition 인스턴스를 생성한 후,
DiscountPolicy 인스턴스에게 전달하여 DiscountCondition의 자리를 대체하도록 해야 함

=> **의존성 주입(Dependency Injection)**
: 컴파일 타임 의존성과 런타임 의존성 사이의 차이를 해결하기 위해 **외부의 객체가 의존하는 객체를 전달하는 방식**

### 의존성 주입 구현 방법
- DiscountPolicy에 **DiscountCondition 타입의 객체를 파라미터로 전달받는 '생성자' 추가**
    - 의존성 변화 없이 런타임에 협력할 수 있는 객체를 선택해서 전달할 수 있게 됨
```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    // 생성자 추가
    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = List.of(conditions);
    }

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

```java
// 새로운 할인 조건을 추가하더라도, DiscountPolicy 객체 생성 시점에 의존성 주입을 통해 새로운 클래스의 인스턴스를 전달하기만 하면 됨
// DiscountPolicy 코드 수정 X
DiscountPolicy policy = new PercentDiscountPolicy(
        0.1,
        new SequenceCondition(1),
        new SequenceCondition(3),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(12, 0)),
        new CombiedCondition( ... )
        );
```

- Movie의 경우에도 마찬가지로 DiscountPolicy 타입을 전달받는 생성자를 추가하고, 객체를 생성하는 시점에 의존성 주입을 통해 새로운 클래스의 인트선스를 전달할 수 있음
- 역시 기존 코드 변경 없이 DiscountPolicy의 타입 확장 가능

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    // 생성자 추가
    public Movie(Money fee, DiscountPolicy discountPolicy) {
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    public Money getFee() {
        return fee;
    }
}
```

### 메시지와 메서드의 분리의 또 다른 장점: 안정적인 구조

- 변경의 파급효과를 제어할 수 있기에 기존 코드 수정없이 기능 확장이 가능하다는 장점 외에도 하나 더!
- => 기능을 확장할 때 따라야 하는 표준적인 구조를 감지할 수 있어서 **지속적으로 기능을 추가하면서도 설계는 일관성 있게 유지 가능** 
- **추상화를 통해 협력 패턴을 고정**시키고 나면, 기능을 확장하기 위해 사용할 수 있는 **안정적인 구조를 얻음**
  - 새로운 할인 정책이나 할인 조건을 추가하려면 DiscountPolicy를 상속받거나 DiscountCondition을 구현하는 방법 외의 다른 방법은 존재하지 않음
  - => 설계 확장을 위한 일관된 방식이 생김
  - => **설계의 구조를 파악하기만 한다면, 새로운 기능을 추가하거나 코드의 구조 에측이 쉬움**

### 예제: 비할인정책 추가

- 할인을 제공하지 않는 정책을 '비할인정책'이라고 하자
- 비할인 정책은 할인 정책의 개수가 0인 경우임 => 가장 간단한 구현은 Movie 클래스의 DiscountPolicy 필드를 null로 지정하는 것
  - 즉, Movie 클래스 생성 시 의존성 주입에서 null을 전달
  - 이후, calculateFee() 메서드 내부에서 discountPolicy가 null인지 체크할 필요

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy; // 비할인 정책은 new Moive(14000, null)과 같이 생성 가능

    public Movie(Money fee, DiscountPolicy discountPolicy) {
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money calculateFee(Screening screening) {
        if (discountPolicy == null) { // discountPolicy가 ㅜull이면 할인 없이 기본 요금 반환하는 로직 추가
            return fee;
        }
        
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    public Money getFee() {
        return fee;
    }
}
```

- 위 설계의 단점
  1. discountPolicy 필드가 null인 Movie를 생성할 수 있음
     - **Movie 안에서 discountPolicy에 접근하는 모든 로직에 null 체크를 추가해야 함을 강요함..**
     - discountPolicy 필드가 비할인 정책인 상태이거나 또는 아직 할인 정책이 할당되지 않은 상태인 2가지 의미로 사용되버림.. => 코드 이해하기 어려움
  2. `calculateFee` 메서드 안에 예외적인 플로우가 추가됨
     - 이전의 Movie는 DiscountPolicy에게 항상 메시지를 전송했지만, 변경 후에는 조건에 따라 메시지를 전송할 수도 있고 전송하지 않을 수도 있음
     - => 코드의 실행 흐름을 이해하기 어려움
- 이 모든 것은 Movie가 참조하는 DiscountPolicy 필드의 값이 null일 수 있기 때문에 발생 (`nullable`)
- => **discountPolicy가 항상 존재하도록 다중성을 변경하면 이 문제 해결 가능**
- => **비할인 정책을 구현하는 `NoneDiscountPolicy` 클래스를 추가**하고, 이를 주입하면 됨

```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO; // 할인 금액 없음
    }
}
```

=> **기존 코드의 수정 없이, 일관된 협력 패턴에 맞춰 새로운 클래스를 추가하면 되기 때문에 코드 확장 용이**

---

## 애플리케이션 객체 추가하기

이번엔 나머지 GRASP 패턴 중 간접화(INDIRECTION), 순수한 가공물(PURE FABRICATION), 컨트롤러(CONTROLLER) 패턴에 대해 알아보자

### 레이어 아키택처로 구성된 애플리케이션

- 애플리케이션을 레이어 아키텍처의 형태로 구성한다고 가정 (ex. 웹 애플리케이션)
  - 프레젠테이션 레이어: 사용자 인터페이스와 관련된 입출력을 책임지는 레이어
  - 도메인 레이어: 도메인 규칙을 구현하는 레이어
  - 퍼시스턴스 레이어: 데이터베이스 접속이나 쿼리 실행을 책임지는 레이어
- 지금까지 우리가 구현한 모든 클래스들은 도메인 로직을 구현하기 때문에 도메인 레이어에 포함됨
- **도메인 로직은 컴퓨터와 관련된 요소들은 배제하고, 순수하게 도메인과 관련된 측면만 표현해야 함**
- 하지만, 컴퓨터 안에서 도메인 로직을 실행하기 위해서는 컴퓨터와 관련된 부가적인 기술 요소 필요
  - ex) 데이터베이스의 도메인 객체를 저장 및 조회하기 위한 '데이터 접근 객체'
  - 모든 도메인 객체들을 메모리에 보관할 수 없기에 대부분의 애플리케이션은 도메인 객체의 상태를 데이터베이스와 같은 영속성 저장소에 저장하고 이를 로드해야 함
- 트랜잭션 관리도 필요
  - 트랜잭션을 시작하고 커밋하거나 롤백하는 데 필요한 기술적인 매커니즘도 필요
  - 예제에서는 스프링 프레임워크가 제공하는 트랜잭션 템플릿을 사용해서 트랜잭션 경계를 처리

구조: `WEB or Console Layer ---> Domain Layer ---> Persistence Layer`

### 프레젠테이션 레이어에서 도메인 로직을 구현한 클래스에 직접 접근한다면?
  - 프레젠테이션 레이어가 사용자 입력 파싱, 트랜잭션 관리, 데이터베이스 접근, 도메인 로직 실행, 결과 반환 등 너무 많은 것을 처리 => **코드 복잡성 증가**
  - 사용자 인터페이스 구현체 사이에 트랜잭션을 관리하고 데이터베이스를 처리하고 도메인 로직을 실행하는 로직이 중복됨 => **중복 코드 문제**

```java
@PostMapping("/reservations")
public ReservationResponse reserve(@RequestBody ReservationRequest request) { // 1) 사용자 입력 파싱
    // 2) 트랜잭션 관리, 데이터베이스 접근, 도메인 로직 실행
   Reservation result = transactionTemplate.execute((status) -> {
       Customer customer = customerDAO.find(request.getCustomerId());
       Screening screening = screeningDAO.find(request.getScreeningId());

       Reservation reservation = screening.reserve(customer, request.getAudienceCount());

       reservationDAO.save(reservation);

       return reservation;
   });

   // 3) 결과 출력
   return new ReservationResponse(result);
}
```

- 해결 방법: 도메인 레이어를 보호하는 **새로운 레이어를 추가**
  - **프레젠테이션 레이어와 도메인 레이어 사이의 의존성을 제거하기 위해** 새로운 레이어를 추가
  - 사용자 인터페이스 구현체가 도메인 객체에 의존하지 않도록 **새로운 레이어의 '중간 객체'를 추가**
    - 이 객체가 트랜잭션 관리 & 데이터베이스 접근 & 도메인 레이어 실행하는 플로우와 관련된 책임 할당
    - **사용자 인터페이스 객체는 단순히 중간 객체에게 처리를 위임하면 됨**

### 간접화(INDIRECTION) 패턴
- 문제: **직접적인 의존을 피하기 위해** 어디에 책임을 할당해야 하는가?
- 해결방법: **다른 컴포넌트나 서비스가 직접 의존하지 않도록 중재하는 '중간 객체'에 책임을 할당**하라

- 중간 객체에 적합한 도메인 개념은?
  - 후보 찾기 위해 도메인 모델을 먼저 봐야하나? => X.. => 이 가이드는 **도메인 로직을 구현할 때만 적용**
  - 도메인 로직에 속하지 않는 객체에게 책임을 할당할 때는 도메인 모델 안에서 **적합한 후보를 찾을 수 없음**

### 순수한 가공물(PURE FABRICATION) 패턴

- 문제: 적합한 책임을 가진 클래스를 찾지 못하는 상황이거나 높은 응집도와 낮은 결합도를 위반하고 싶지 않은 경우, 누구에게 책임을 할당해야 하는가?
- 해결 방법
  - **도메인 개념을 표현하지 않는 인위적으로 만든 클래스에 책임을 할당**하라.
  - 이런 클래스는 높은 응집도, 낮은 결합도, 재사용을 위해 만들어진다

=> 프레젠테이션 레이어와 도메인 레이어 사이에 높은 결합도 문제를 해결하기 위해 도입한 **중간 객체는 대응되는 도메인 개념 존재 X**
=> 중간 객체는 도메인과 무관한 인위적인 객체를 추가해서 응집도를 높이고 결합도를 낮추고 재사용성을 향상시키기 위해 순수한 가공물 패턴을 적용한 예시임

### 컨트롤러(CONTROLLER) 패턴

- 문제: UI 계층(프레젠테이션 레이어)을 통해 전달되는 시스템의 오퍼레이션을 전달받고 조정(제어할) 최초의 객체는 무엇인가?
- 해결 방법: 워크플로우(애플리케이션 로직)를 표현하는 객체에게 책임을 할당하라

- => 순수한 가공물 중에서 **사용자 인터페이스에게 기능을 제공하기 위한 책임을 할당**함으로써 결합도를 낮추는 패턴
- 중간 객체는 컨트롤러 패턴을 적용한 예시임
- 컨트롤러 패턴은 트랜잭션을 시작 & 데이터베이스 조회 & 도메인 로직 실행 & 실행 결과를 데이터베이스에 저장하는 워크플로우를 조율하는 역할을 수행함
  - 이러한 **워크플로우를 '애플리케이션 로직'이라고 부름**
  - **애플리케이션 로직을 구현하는 중간 객체** = **'애플리케이션 서비스'**
  - 애플리케이션 서비스는 도메인 레이어와 프레젠테이션 레이어 사이에 위치하고, **애플리케이션 서비스가 위치하는 레이어를 '서비스 레이어'**라고 부름
- 애플리케이션 서비스를 추가하면 사용자 인터페이스 객체는 애플리케이션 서비스인 ReservationService의 처리를 위임할 수 있음
- => 사용자 인터페이스의 클래스의 복잡도를 낮출 수 있음
- + 두 클래스 사이에 존재하던 중복 로직을 ReservationService로 옮길 수 있음 => 중복 코드 제거

`WEB or Console Layer ---> Service Layer ---> Domain Layer ---> Persistence Layer`

```java

@Service
public class ReservationService {
  private CustomerDAO customerDAO;
  private ScreeningDAO screeningDAO;
  private ReservationDAO reservationDAO;

  public ReservationService(TransactionTemplate transactionTemplate, CustomerDAO customerDAO, ScreeningDAO screeningDAO, ReservationDAO reservationDAO) {
    this.transactionTemplate = transactionTemplate;
    this.customerDAO = customerDAO;
    this.screeningDAO = screeningDAO;
    this.reservationDAO = reservationDAO;
  }

  @Transactional
  public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {
    Customer customer = customerDAO.find(customerId);
    Screening screening = screeningDAO.find(screeningId);

    Reservation reservation = screening.reserve(customer, audienceCount);

    reservationDAO.save(reservation);

    return reservation;
  }
}
```

```java
// ReservationController
@PostMapping("/reservations")
public ReservationResponse reserve(@RequestBody ReservationRequest request) {
    Reservation result = reservationService.reserveScreening(
                            request.getCustomerId(),
                            request.getScreeningId(),
                            request.getAudienceCount());

    return new ReservationResponse(result);
}
```

### 데이터 접근 객체 다시 살펴보기
- 데이터 접근 객체 역시 간접화 패턴을 적용한 예시임
  - 도메인 객체가 데이터베이스에 의존하지 않도록 하기 위해 데이터 접근 객체를 추가해서 데이터베이스에 대한 책임을 처리
- 또한, 데이터 접근 객체는 순수한 가공물 패턴의 예시임
  - 데이터 접근 객체의 개념은 도메인 모델 안에 존재하지 않기 때문

---

## 정리

- 객체 구현하기
  - 다형성 패턴 + 변경 보호 패턴의 적용 = 추상화의 도입 = '역할' 추가
  - **역할을 구현하는 방법**
    - 하나의 객체만 표현한다면 -> **구체 클래스**를 이용해 구현
    - 여러 객체에 의해 대체될 수 있고 **코드를 공유해야 한다면** -> **추상 클래스**를 이용해서 구현
    - 코드를 공유할 필요도 없고, **결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원한다면** -> **인터페이스**를 통해 구현
  - 결과
    - 완성된 **클래스의 구조는 도메인 개념의 구조와 거의 유사**
    - 구현할 때 **도메인 모델 안에 포함된 개념과 관계에 기반해서 책임을 할당할 대체를 선택했기 때문**
    - => **요구사항 변경 시 수정할 코드를 찾기 쉬움**
- 메시지와 메서드의 분리
  - **수정하기 쉬운 코드를 작성하기 위해** 다형성에 기반해 메시지와 메서드를 분리할 필요
  - 메시지와 메서드를 분리하면 클라이언트는 메시지에만 의존하기 때문에 메시지를 처리할 수 있는 어떤 객체와도 협력 가능
    - **동적 바인딩**: **런타임의 객체가 메시지를 처리하기에 적절한 클래스와 메서드를 결정하는 방식**
    - => **추상화를 통해 협력 패턴을 고정**
  - 변경하기 쉬운 구조 설계를 위해서는 **메시지를 먼저 결정하고 이를 수신할 객체를 나중에 선택**
  - 장점
    - 변경의 파급효과를 제어 -> 기존 코드 수정없이 기능 확장이 가능
    - **안정적인 구조를 얻음** -> **설계의 구조를 파악하기만 한다면, 새로운 기능을 추가하거나 코드의 구조 에측이 쉬움**
- 메시지와 메서드를 분리하는 것까지는 좋으나 **컴파일 타임 의존성과 런타임 의존성이 서로 다름**
  - **의존성 주입(Dependency Injection)**을 통해 해결
    - 컴파일 타임 의존성과 런타임 의존성 사이의 차이를 해결하기 위해 **외부의 객체가 의존하는 객체를 전달하는 방식**
    - 생성자를 추가하여 구현 가능
- 간접화(INDIRECTION), 순수한 가공물(PURE FABRICATION), 컨트롤러(CONTROLLER) 패턴
  - 프레젠테이션 레이어가 도메인 레이어에 의존하고 너무 많은 책임을 가져서 코드 복잡성 증가, 중복 코드 문제가 있었음
  - 사용자 인터페이스 구현체가 도메인 객체에 의존하지 않도록 **새로운 레이어의 '중간 객체'를 추가**
  - 이는 간접화(INDIRECTION), 순수한 가공물(PURE FABRICATION), 컨트롤러(CONTROLLER) 패턴을 적용한 예시라고 볼 수 있음