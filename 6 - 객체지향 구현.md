# 객체지향 구현 (영화 예매 시스템)

이전 시간까지는 행동 결정 후 객체를 선택하는 방법을 다뤘다면,
이번에는 행동과 데이터를 이용해서 클래스를 구현해보자

## 객체 구현하기


### 영화 예매 책임 구현
- 상영은 영화를 예매할 수 있다 = 내부적으로 예매(Reservation) 객체를 생성한다
- 예매 객체 생성을 위해서는 영화의 가격이 필요한데, 응집도 관점에서 상영이 직접 계산하는 것보다는 영화에게 가격 계산을 요청하는 것이 좋다
- => 상영(`Screening`)은 가격 계산을 위해 영화(`Movie`)와 협력해야 한다

```java
public class Screening {
    // reserve 메서드 구현 시 movie가 필요하므로 추가
    private Movie movie;

    // 먼저 구현
    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }
}
```

### 영화에 할당된 가격을 계산하는 책임 구현
- 영화를 구현할 클래스인 Movie와 가격을 계산하는 책임을 구현할 메서드인 `calculateFee`의 시그니처는 Screening을 구현하면서 이미 결정되었다
- 따라서, Movie 클래스를 생성하고 그 안에 `calculateFee` 메서드를 추가하자

```java
// 먼저 메서드 추가
public class Movie {

    public Money calculateFee(Screening screening) {
    }
}
```

- 영화는 할인 금액을 게산하기 위해 할인 정책에게 할인 요금을 계산할 것을 요청한다
- => 영화는 할인 정책과 협력
- Movie 클래스는 할인금액을 게산하기 위해 할인 정책인 DiscountPolicy에게 `calculateDiscount` 메시지를 전송하고, 반환된 할인 금액을 영화의 정가인 `fee`에서 차감한다
- => 영화의 정가를 저장할 `fee`와 할인 금액을 계산할 `discountPolicy`가 필드로 필요하므로 추가하자

```java
// 이후 구현하면서 필드 추가
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }
}
```

### 할인 정책에 할당된 할인 금액을 계산하는 책임 구현
- 영화와 할인 사이의 협력을 설계할 때 코드를 변경하기 쉽게 만들기 위해 다형성 패턴을 적용했었음
  - 영화는 할인을 계산하라는 '다형적인 메시지'를 전송하고,
  - 실제로 메시지를 수신하는 객체의 타입이 비율 할인 정책인지, 금액 할인 정책이닞에 따라 적절한 메서드가 실행되도록 협력을 설계했음 (변경 보호 패턴 적용)
- 영화는 추상화인 할인 정책(`DiscountPolicy`)에 대해서만 의존하고, 비율 할인 정책이나 금액 할인 정책에 대해서는 알지 못함
  - 할인 정책은 여러 객체에 의해 대체될 수 있으므로 '역할(Role)'임
- **역할을 구현하는 방법**
  - 하나의 객체만 표현한다면 -> **구체 클래스**를 이용해 구현
  - 여러 객체에 의해 대체될 수 있고 **코드를 공유해야 한다면** -> **추상 클래스**를 이용해서 구현
  - 코드를 공유할 필요도 없고, **결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원한다면** -> **인터페이스**를 통해 구현
- 여기서는 데이터 로직을 공유해야 하므로 추상 클래스를 통해 DiscountPolicy를 구현

```java
// DiscountPolicy - 추상 클래스
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    // 추상 클래스로 선언했음에 주목하자
    // 자식 클래스(금액 할인 정책, 비율 할인 정책)은 이 메서드를 오버라이딩 해서 자신만의 방법으로 할인 금액을 계산 가능
    abstract protected Money getDiscountAmount(Screening screening);
}
```

```java
// AmountDiscountPolicy - 자식 클래스
public class AmountDiscountPolicy extends DiscountPolicy {
    private Money discountAmount;

    // 오버라이딩
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return discountAmount;
    }
}
```

```java
// PercentDiscountPolicy - 자식 클래스
public class PercentDiscountPolicy extends DiscountPolicy {
    private double percent;

    // 오버라이딩 (주목)
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return screening.getFixedFee().times(percent);
    }
}
```

- 협력을 통해 현재 객체가 할 수 없는 일을 다른 객체에게 요청함으로써 더 큰 작업 수행
    - PercentDiscountPolicy의 `getDiscountAmount`에서 영화의 정가는 Screening의 `getFixedFee()` 메서드를 통해 얻어옴
        - Screening은 Movie를 알고 있고, Movie는 영화의 정가를 알고있으므로 Screening을 통해 가져오는 것

```java
// Screening에 getFixedFee() 추가
public class Screening {
    private Movie movie;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    // 추가
    public Money getFixedFee() {
        return movie.getFee();
    }
}
```

```java
// Movie에 getFee() 추가
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    // 추가
    public Money getFee() {
        return fee;
    }
}
```

- 절차적인 방식의 Movie는 사용되는 문맥을 모르는 상태에서 추측에 기반해 getter/setter를 추가했음
- 반면, 객체지향 방식의 Movie는 협력을 설계하는 과정에서 할당된 책임에 기반하여 꼭 필요한 경우에만 메서드를 추가했음
- => 변경에 있어서 더 유리함

### 할인 조건 구현
- 할인 조건도 할인 정책처럼 다형적인 메시지를 추상화에 전송하고, 메시지를 수신한 객체가 자신의 타입에 기반해서 적합한 행동을 수행
- 앞서, DiscountPolicy의 `calculateDiscount` 메서드에서 할인 여부를 판단하기 위해 DiscountCondition에게 `isSatisfiedBy` 메시지를 전송했음
  - 할인 조건의 타입은 하나가 아니기 때문에 이 `isSatisfiedBy` 메시지를 수신할 DiscountCondition 인스턴스는 자신에게 적합한 행동을 선택해야 함
  - 기간 조건과 순서 조건은 로직이나 데이터를 공유할 필요가 없음 => 결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원함 => **인터페이스로 정의**

```java
public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}
```

- SequenceCondition은 Screening에게 회차가 동일한지를 비교하는 `isSequence` 메시지를 전송
  - Screening이 협력에 참여하기 위해 `isSequence` 메서드 구현 필요

```java
// SequenceCondition의 isSatisfiedBy 구현 및 데이터 추가
public class SequenceCondition implements DiscountCondition {
    private int sequence;

    @Override
    public boolean isSatisfiedBy(Screening screening) {
        return screening.isSequence(sequence);
    }
}
```

```java
// Screening에 isSequence 메서드 구현 추가
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    public Money getFixedFee() {
        return movie.getFee();
    }

    // 추가
    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }
}
```

- PeriodCondition은 Screening의 상영 시작 시간이 조건에 명시된 요일과 동일하고 시간 범위에 포함되는지 확인
  - 이를 위해 dayOfWeek, startTime, endTime 필드를 추가하고, 이 필드를 이용해서 할인 여부를 판단하도록 구현
  - Screening의 `getStartTime` 메시지 전송 -> Screening이 협력에 참여하기 위해 `getStartTime` 추가

```java
// isSatisfiedBy 구현 & 데이터 필드 추가
public class PeriodCondition implements DiscountCondition {
    private DayOfWeek dayOfWeek;
    private LocalTime startTime, endTime;

    public boolean isSatisfiedBy(Screening screening) {
        return  screening.getStartTime()
                .getDayOfWeek().equals(dayOfWeek) &&
                startTime.compareTo(screening.getStartTime().toLocalTime()) <= 0 &&
                endTime.compareTo( screening.getStartTime()
                        .toLocalTime()) >= 0;
    }
}
```

```java
// getStartTime() 추가
public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Reservation reserve(Customer customer, int audienceCount) {
        Money fee = movie.calculateFee(this).times(audienceCount);
        return new Reservation(customer, this, audienceCount, fee);
    }

    public Money getFixedFee() {
        return movie.getFee();
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    // 추가
    public LocalDateTime getStartTime() {
        return whenScreened;
    }
}
```

### 클래스 구조와 도메인 개념 구조 비교

이렇게 완성된 **클래스의 구조는 도메인 개념의 구조와 거의 유사**하다.
두 구조가 유사한 형태를 띠는 것은 우연이 아니라 예매 기능을 구현할 때 **도메인 모델 안에 포함된 개념과 관계에 기반해서 책임을 할당할 대체를 선택했기 때문**

이렇게 코드를 도메인과 유사한 형태로 설계하는 이유? => **표현적 차이를 줄이기 위해**
표현적 차이를 줄이는 이유? => 코드가 도메인과 유사하면 **요구사항 변경 시 수정할 코드를 찾기 쉬움**

### 위임식(delegated) / 분산식(dispersed) 제어 스타일

- 절차적인 방식 -> 모든 제어가 프로세스를 구현한 코드로 집중되었음
- 객체지향 방식 -> 제엉가 여러 객체 사이로 분배됨
  - 객체지향 애플리케이션은 스스로를 책임지는 자율적인 객체들로 구성되기 때문
  - 객체는 자신이 할수 없는 일을 다른 객체에게 위임
  - => 제어 분산
  - => 수정하기 쉽고 더 유연한 설계

## 메시지와 메서드의 분리

객체를 이용해서 애플리케이션을 설계하기 위해서는 **메시지와 메서드의 개념**을 이해하는 것이 중요

### 메시지(message)와 메서드(method)
- 메시지: 한 객체가 다른 객체와 의사소통할 수 있는 유일한 방법
- 메서드: 메시지를 수신한 객체가 메시지를 처리하기 위해 수행하는 행동
    - 동일한 메시지를 전송하더라도, 메시지를 수신한 객체는 자신의 타입에 맞는 적절한 메서드를 선택한 후 실행 가능

### 메시지와 메서드의 분리는 다형성의 기반

- 다형성은 메시지와 메서드를 분리하고 런타임에 이들을 조합해서 다양한 종류의 객체들이 협력할 수 있도록 구성하는 객체지향만의 독특한 매커니즘에 기반함
- 이렇게 복잡한 과정을 거치면서까지 메시지와 메서드를 분리해야 하는 이유가 뭘까?
  - => 의존성을 제어해서 내부의 데이터가 변경되거나 타입이 바뀔 때의 파급효과를 제어하기 위해서 
  - => 즉, **수정하기 쉬운 코드를 작성하기 위해**

- 메시지와 메서드를 분리하면 클라이언트는 메시지에만 의존하기 때문에 메시지를 처리할 수 있는 어떤 객체와도 협력 가능
- => 즉, 클라이언트의 코드 수정 없이 협력할 객체 타입을 쉽게 변경 가능

### 메시지를 먼저 결정

- 변경하기 쉬운 구조 설계를 위해서는 **메시지를 먼저 결정하고 이를 수신할 객체를 나중에 선택**
- 이는 객체지향 설계 원칙에서 '행동 먼저 결정, 적합한 객체 나중에 선택'과 동일
  - '다른 객체가 행동하도록 전송하는 요청 = 메시지'이기 때문
- 자바와 같은 강타입 언어에서는 메시지만 단독으로 사용할 수 없고, 대신 **메시지를 포함한 명확한 타입을 정의해야 함**
  - => 예제에서 `isSatisfiedBy` 메시지를 정의하기 위해 `DiscountCondition`이라는 인터페이스를 정의한 이유
  - DiscountCondition 인터페이스를 구현한 객체는 이 협력에 참여 가능
- **DiscountPolicy가 메시지에만 의존**하고 있기 때문에 **새로운 타입의 할인 조건을 추가하더라도 DiscountPolicy는 수정할 필요가 없음**

### 동적 바인딩

*DiscountPolicy가 DiscountCondition 인터페이스에만 의존하는데도 런타임에 Sequenceondition과 PeriodCondition의 메서드를 어떻게 실행 가능할까?*

- 객체지향에서는 실행될 메서드가 **런타임에 결정**되기 때문
- 런타임에서 어떤 클래스가 인터페이스르 대체하는지에 따라 서로 다른 메서드가 실행됨
- 이처럼, 런타임의 객체가 메시지를 처리하기에 적절한 클래스와 메서드를 결정하는 방식 => 동적 바인딩

### 객체지향의 기반은 자율적인 객체

- 객체는 자기 자신을 스스로 책임져야 하기 때문에, **메시지를 수신했을 때 자기 자신이 어떤 일을 해야 하는지 스스로 결정**
- 동적 바인딩은 객체가 자율적인어야 한다는 객체지향의 철학을 뒷받침함

## 유연하고 일관적인 협력

### 남아있는 문제: 컴파일 타임 의존성과 런타임 의존성

- 코드 레벨에서 DiscountPolicy는 오직 DiscountCondition 인터페이스에만 의존
- 하지만, 런타임에는 DiscountPolicy 객체가 SequenceCondition과 PeriodCondition 객체에게 메시지를 전송할 수 있어야 함
- => **컴파일 타임 의존성과 런타임 의존성이 서로 다름**

이를 해결하기 위해서는 외부의 객체가 SequenceCondition 인스턴스나 PeriodCondition 인스턴스를 생성한 후,
DiscountPolicy 인스턴스에게 전달하여 DiscountCondition의 자리를 대체하도록 해야 함

=> **의존성 주입(Dependency Injection)**
: 컴파일 타임 의존성과 런타임 의존성 사이의 차이를 해결하기 위해 **외부의 객체가 의존하는 객체를 전달하는 방식**

### 의존성 주입 구현 방법
- DiscountPolicy에 **DiscountCondition 타입의 객체를 파라미터로 전달받는 생성자 추가**
    - 의존성 변화 없이 런타임에 협력할 수 있는 객체를 선택해서 전달할 수 있게 됨
```java
public abstract class DiscountPolicy {
    private List<DiscountCondition> conditions;

    // 생성자 추가
    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = List.of(conditions);
    }

    public Money calculateDiscount(Screening screening) {
        for (DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening screening);
}
```

```java
// 새로운 할인 조건을 추가하더라도, DiscountPolicy 객체 생성 시점에 의존성 주입을 통해 새로운 클래스의 인스턴스를 전달하기만 하면 됨
// DiscountPolicy 코드 수정 X
DiscountPolicy policy = new PercentDiscountPolicy(
        0.1,
        new SequenceCondition(1),
        new SequenceCondition(3),
        new PeriodCondition(DayOfWeek.MONDAY, LocalTime.of(10, 0), LocalTime.of(12, 0)),
        new CombiedCondition( ... )
        );
```

- Movie의 경우에도 마찬가지로 DiscountPolicy 타입을 전달받는 생성자를 추가하고, 객체를 생성하는 시점에 의존성 주입을 통해 새로운 클래스의 인트선스를 전달할 수 있음
- 역시 기존 코드 변경 없이 DiscountPolicy의 타입 확장 가능

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy;

    // 생성자 추가
    public Movie(Money fee, DiscountPolicy discountPolicy) {
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money calculateFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    public Money getFee() {
        return fee;
    }
}
```

### 메시지와 메서드의 분리의 또 다른 장점: 안정적인 구조

- 변경의 파급효과를 제어할 수 있기에 기존 코드 수정없이 기능 확장이 가능하다는 장점 외에도 하나 더!
- => 기능을 확장할 때 따라야 하는 표준적인 구조를 감지할 수 있어서 **지속적으로 기능을 추가하면서도 설계는 일관성 있게 유지 가능** 
- **추상화를 통해 협력 패턴을 고정**시키고 나면, 기능을 확장하기 위해 사용할 수 있는 **안정적인 구조를 얻음**
  - 새로운 할인 정책이나 할인 조건을 추가하려면 DiscountPolicy를 상속받거나 DiscountCondition을 구현하는 방법 외의 다른 방법은 존재하지 않음
  - => 설계 확장을 위한 일관된 방식이 생김
  - => **설계의 구조를 파악하기만 한다면, 새로운 기능을 추가하거나 코드의 구조 에측이 쉬움**

### 예제: 비할인정책 추가

- 할인을 제공하지 않는 정책을 '비할인정책'이라고 하자
- 비할인 정책은 할인 정책의 개수가 0인 경우임 => 가장 간단한 구현은 Movie 클래스의 DiscountPolicy 필드를 null로 지정하는 것
  - 즉, Movie 클래스 생성 시 의존성 주입에서 null을 전달
  - 이후, calculateFee() 메서드 내부에서 discountPolicy가 null인지 체크할 필요

```java
public class Movie {
    private Money fee;
    private DiscountPolicy discountPolicy; // 비할인 정책은 new Moive(14000, null)과 같이 생성 가능

    public Movie(Money fee, DiscountPolicy discountPolicy) {
        this.fee = fee;
        this.discountPolicy = discountPolicy;
    }

    public Money calculateFee(Screening screening) {
        if (discountPolicy == null) { // discountPolicy가 ㅜull이면 할인 없이 기본 요금 반환하는 로직 추가
            return fee;
        }
        
        return fee.minus(discountPolicy.calculateDiscount(screening));
    }

    public Money getFee() {
        return fee;
    }
}
```

- 위 설계의 단점
  1. discountPolicy 필드가 null인 Movie를 생성할 수 있음
     - **Movie 안에서 discountPolicy에 접근하는 모든 로직에 null 체크를 추가해야 함을 강요함..**
     - discountPolicy 필드가 비할인 정책인 상태이거나 또는 아직 할인 정책이 할당되지 않은 상태인 2가지 의미로 사용되버림.. => 코드 이해하기 어려움
  2. `calculateFee` 메서드 안에 예외적인 플로우가 추가됨
     - 이전의 Movie는 DiscountPolicy에게 항상 메시지를 전송했지만, 변경 후에는 조건에 따라 메시지를 전송할 수도 있고 전송하지 않을 수도 있음
     - => 코드의 실행 흐름을 이해하기 어려움
- 이 모든 것은 Movie가 참조하는 DiscountPolicy 필드의 값이 null일 수 있기 때문에 발생 (nullable)
- => **discountPolicy가 항상 존재하도록 다중성을 변경하면 이 문제 해결 가능**
- => **비할인 정책을 구현하는 `NoneDiscountPolicy` 클래스를 추가**하고, 이를 주입하면 됨

```java
public class NoneDiscountPolicy extends DiscountPolicy {
    @Override
    protected Money getDiscountAmount(Screening screening) {
        return Money.ZERO; // 할인 금액 없음
    }
}
```

- **기존 코드의 수정 없이, 일관된 협력 패턴에 맞춰 새로운 클래스를 추가하면 되기 때문에 코드 확장 용이**

## 애플리케이션 객체 추가하기
