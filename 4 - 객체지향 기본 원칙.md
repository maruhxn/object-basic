# 객체지향 기본 원칙

## 객체지향 설계 원칙

- 설계(Design)란?
  - : 코드를 배치하는 방식
  - (객체지향) 설계가 필요한 이유 => **요구사항이 변경될 때 코드를 쉽고 안전하게 수정하기 위해서**
- 객체지향 설계 원칙
  - 객체지향의 모든 원칙은 변경을 중심에 두고 있음
  - 1. **_협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택해라_**
  - 2. **_행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 선택해라_**
  - => 행동을 먼저 결정하고, 객체와 데이터는 나중에 선택해라

### 행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 선택해라

절차적인 설계에서 처음에 DiscountPolicy의 모든 Getter/Setter를 열어두고 이를 ReservationService에서 사용했던 것을 다시 살펴보자
이 경우, 데이터(DiscountPolicy)의 구조가 프로세스(ReservationService)에 그대로 노출되기 때문에 **ReservationService는 DiscountPolicy의 내부 구조에 강하게 결합**되었다.

이를 해결하기 위해서 우리는 데이터와 프로세스를 하나의 모듈 안에 함께 담으려고 했고, 그 결과 ReservationService에서 DiscountPolicy를 참조하는 로직(`calculateDiscount`)을 DiscountPolicy 내부로 옮기고,
ReservationService는 이를 호출하기만 하는 형태로 변경하였다.

=> **책임의 이동**
=> 프로세스를 구현한 코드는 더 이상 데이터 내부 구조에 의존하지 않게 됨
=> **데이터 구조를 변경해도 영향을 받지 않음!**

설계를 개선하기 전에는 **데이터의 구조에 의존**했지만,
**설게를 개선한 후에는 외부에 노출된 메소드에 의존**함
=> 외부 객체가 데이터가 아닌 **행동에 의존**하도록 만듦

외부 객체가 데이터에 의존하지 않고 행동에 의존하도록 만드는 가장 좋은 방법은 **데이터를 결정하기 전에 행동부터 결정하는 것**
데이터가 없는 상태에서 행동 먼저 결정한다면, 외부에서는 데이터에 대해 모르기에 행동에만 의존할 수밖에 없음

DiscountPolicy가 텅 빈 클래스라고 할 때, `calculateDiscount`를 먼저 만들고, 이를 구현하기 위해 필요한 데이터를 DiscountPolicy의 필드에 추가
=> 즉, 클래스가 어떤 필드를 가질지를 먼저 결정하는 것이 아니라, **어떤 행동(메서드)를 가져야 하는지를 먼저 결정한 후, 이를 구현하면서 필요하다고 판단되는 필드를 추가하는 방식**

DiscountPolicy 클래스 안에 calculateDiscount 메소드를 추가한 이유는 무엇?
=> **ReservationService가 할인 금액을 계산하기를 원했기 때문**
=> DiscountPolicy 객체는 ReservationService의 요청에 응답하기 위해 이를 위한 행동(calculateDiscount)를 외부에 제공하고 있음

### 협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택해라

- 클래스를 고립시킨 상태에서 외부에 제공할 행동을 결정해서는 안됨
- **객체는 다른 객체가 사용할 필요가 있는 행동만을 외부에 제공**해야 함
- 객체의 행동은 고립된 상태가 아닌, **다른 객체와의 '협력'이라는 문맥 안에서 결정**해야 함
  - ex) 할인 금액이 필요한 클라이언트의 요청이 협력에 필요한 행동을 결정 -> 이 행동을 제공하기에 적합한 객체(DiscountPolicy)를 선택
- 행동을 먼저 결정하고 데이터를 나중에 선택함으로써 데이터가 변경되더라도 외부에 영향 X

- `협력(Collaboration)`
  - 객체가 다른 객체에게 도움을 얻기 위해 요청하고 응답하는 과정
  - ex) ReservationService 객체는 DiscountPolicy 객체와 협력하기 위해, `calculateDiscount` 요청을 전송하고 있음

객체지향 설계에서는 객체르 설계하는데 필요한 문맥을 결정한 후, 설계를 진행
이러한 문맥의 존재 유무가 코드의 유지 보수성에 큰 영향을 미침
**객체가 다른 객체와 협력하려는 필요성이 설계를 위한 문맥을 제공**
=> 객체지향 설계에서는 객체와 객체 사이의 **협력을 먼저 결정**

### 정리

**_협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택해라_**
= 협력에 필요한 행동을 구현하면서 필요한 데이터를 나중에 결정
=> **클래스의 내부 구현이 완성**됨
=> **협력하는 객체가 데이터에 의존하지 않도록 만들어주기 때문에 코드를 수정하지 않고도 데이터를 변경할 수 있게 해줌**

**_협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택해라_**
= 협력에 필요한 행동 먼저 결정한 후, 행동에 필요한 객체를 나중에 선택
=> **객체 사이의 협력이 설계**됨
=> **객체를 선택하기 전에 요청을 결정하기 때문에 코드를 수정하지 않고도 협력하는 객체를 교체할 수 있음**

=> **객체들의 협력 관계를 기반으로 애플리케이션을 설계**하는 방법 = **책임 주도 설계**

## 책임 주도 설계

### 객체지향 설계 흐름

1. **협력을 위한 '문맥' 결정**

- 객체가 다른 객체와 협력하기 위해 보내는 요청을 객체를 설계하기 위한 문맥으로 활용

2. **필요한 '책임'을 식별**
3. **책임을 수행할 '객체'를 선택**
4. **'책임' 구현**

- 클래스와 메서드를 이용하는 것이 일반적

5. **'데이터' 결정**

- 책임을 구현하는데 핑료한 데이터를 결정하고 클래스의 필드로 정의

### 책임(Responsibility)

- : **협력에 참여하기 위해 객체가 수행하는 행동**
- 객체들은 자신에게 할당된 **책임을 수행함으로써 다른 객체와 협력**하게 됨
- 책임의 2가지 범주
  - **하는 것(Doing)**
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체(협력자)의 행동을 시작시키는 것
    - 다른 객체(협력자)의 활동을 제어하고 조절하는 것
  - **아는 것(Knowing)**
    - private로 캡슐화된 상태(데이터)에 관해 아는 것
    - 관련된 객체(협력자)에 관하여 아는 것
    - 자신이 유도하거나 계산할 수 있는 것(상태와 협력자)에 관하여 아는 것
- **책임은 행동과 관련**이 있음
- 객체지향에서 책임이 중요한 이유: **객체의 구현이 아니라 '협력'에 초점**을 맞출 수 있기 때문
  - 책임 관점에서 객체 설계 시 객체 내부의 세부 사항에 대한 결정은 뒤로 미루고 외부에 제공해야 하는 행동을 먼저 결정 가능

**_협력이 책임을 설계하는데 필요한 문맥을 제공한다면, 협력을 설계하는 데에 필요한 '문맥'은 어디서 얻을 수 있을까?_**
=> **시스템이 외부에 제공해야 하는 기능**을 협력을 위한 **문맥으로 사용**함

### 책임 주도 설계 살펴보기

1. 애플리케이션이 **제공할 기능 파악**

- 이 기능을 협력을 설계하기 위한 **'문맥'으로 활용**
- ex) 영화 예매하기

2. 애플리케이션의 기능 요구사항을 **시스템의 책임으로 변환**
3. 시스템의 책임을 **객체의 책임으로 변환**

- 이제 설계의 문맥은 시스템 외부에 제공할 기능에서 **시스템 내부에 존재하는 객체 사이의 협력으로 바뀌게 됨**

4. 책임을 담당할 **적절한 객체 선택**
5. 객체의 책임 일부를 수행하기 위해 **외부의 도움이 필요하다면, 다른 객체에게 도움 요청**
6. 이 요청을 또 다른 객체의 책임으로 변환
7. 책임을 담당할 적절한 객체 선택

1 ~ 7 반복..

### 객체지향 설계 순서

- 런타임에서 실제로 동작하는 객체 사이의 '협력'을 먼저 결정하기 (런타임 구조)
- 이 협력을 실현하는데 필요한 클래스를 구현하는 순서로 진행 (컴파일타임 구조)

### 요약

- 책임 주도 설계에서는 **2가지 문맥 사용**
  - 하나는 협력을 설계하기 위해 사용하는 **'애플리케이션 기능'**
  - 다른 하나는 객체에게 책임을 할당하기 위해 사용하는 **'협력'**이라는 문맥

## 표현적 차이 줄이기

### 알고리즘과 객체지향 설계

- 객체지향이라고 해서 알고리즘을 생각하지 않는 것이 아님. 단지, **알고리즘 배치 방식이 절차적인 방식과 다를 뿐**
  - 절차적 방식 => 알고리즘을 하나의 클래스 안에 실행 순서대로 배치
  - 객체지향 방식 => **알고리즘을 어떤 원칙에 따라 여러 개의 객체로 분배**
- 알고리즘을 구성하는 로직을 적합한 객체에게 분배하는 일 = **'책임 할당'**

_책임을 할당한 객체는 어디에서 얻을 수 있는 것일까?_
_어떤 객체에게 책임을 할당해야 할까?_
=> **도메인 모델**에서 참조하자

### 도메인 모델

- 가장 처음에 정의한 도메인에는 '도메인 개념'이 존재
- `도메인 모델(Domain Model)`: **도메인에 존재하는 중요한 개념과 관계를 모아서 이해하기 쉽게 추상화시킨 것**
  - 추상화: 의도적으로 우리가 사용할 용도에 적합한 부분만 취하고 나머지는 버리는 것
- 도메인 모델의 용도: 후보 객체를 찾을 때 가장 먼저 참고하는 개념과 관계의 집합
  - **도메인 모델 안에 포함된 개념과 관계는 객체지향 설계에서 책임을 할당받을 객체의 이름과 관계에 대한 중요한 힌트를 제공**
- 도메인 모델을 참고하는 이유?: **표현적 차이를 줄이기 위함**

### 표현적 차이(Representational Gap)

- : 도메인에 대한 개념적 모델과 소프트웨어 구현 사이의 거리
- 일반적으로 절차적인 방식으로 작성된 코드는 표현적 차이가 크고, **객체지향적으로 작성된 코드는 표현적 차이가 작음**
- 표현적 차이를 줄이는 이유?: **변경하기 쉬운 유연한 설계를 만들기 위해**

### 안정적인 도메인

- 도메인의 개념과 기본 구조는 비즈니스가 바뀌지 않는 이상 그대로 유지
- => **안정적인 도메인에 기반한 코드 구조(설계) 역시 변경에 안정적**
- => 요구사항 변경에도 쉽고 안정적으로 코드 수정 가능

### 은유: 표현적 차이를 줄이기 위한 방법

- 표현적 차이를 주링기 위해서는 **객체가 도메인 개념을 은유하도록 만들어야 함**
- 은유: 유사한 다른 개념을 이용해서 어떤 개념을 서술하는 방식
  - 한 가지 개념을 이해하고 나면 유사한 다른 개념을 이 개념을 통해 쉽게 이해할 수 있음
- 객체지향 설계에서의 은유 => **어떤 책임을 수행하기에 적합한 객체를 우리에게 익숙한 도메인 개념과 연결시켜 줌**
  - ex) 도메인 안에서 할인 여부를 판단하기 위한 규칙을 '할인 조건'이랃고 부르고 있으므로, 할인 조건에 해당하는 `DiscountCondition`을 객체 이름으로 사용하면 이 객체가 할인 여부를 판단한다는 사실을 쉽게 떠올릴 수 있음
- => 도메인 개념을 은유해서 **객체와 클래스의 이름을 지으면 책임을 구현한 코드를 찾기 쉬움**
- => **수정할 코드의 위치 파악에도 용이**

### GRASP(General Responsibility Assignment Software Pattern)

- 일반적인 책임 할당을 위한 소프트웨어 패턴
- 패턴 종류 9가지 (이중 \* 표시된 6가지를 살펴볼 예정)
  - `CREATOR(창조자)` (\*)
  - `INFORMATION EXPERT(정보 전문가)` (\*)
  - `LOW COUPLING(낮은 결합도)` (\*)
  - `HIGH COHESION(높은 응집도)` (\*)
  - `CONTROLLER(컨트롤러)`
  - `INDIRECTION(간접화)`
  - `POLYMORPHISM(다형성)` (\*)
  - `PROTECTED VARIATIONS(변경 보호)` (\*)
  - `PURE FABCRICATION(순수한 가공물)`

### CRC 카드

- 책임과 협력을 표현하기 위한 객체지향 설계 도구
- 물리적인 인덱스 카드를 이용해서 책임을 기술할 수 있는 설계 도구
- CRC는 Candidate(후보, 역할 또는 객체), Responsibility(책임), Collaborator(협력자)의 약자로 **CRC 카드 한 장이 객체 하나를 의미**
  - Candidate에는 '객체' 또는 '역할'을 적음 (역할은 나중에 설명)
  - Responsibility에는 객체가 수행할 책임 기입
  - Collaborator에는 협력할 다른 객체 기입
- CRC 카드는 책임을 다루기 때문에 **런타임에 객체 협력을 설계하는 용도로 사용** => 클래스와 유사해보이더라도 정적인 클래스가 아닌 **동적인 객체를 나타냄**
