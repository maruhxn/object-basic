# 절차적인 설계로 구현하기

- 절차적(Procedural) 설계란?

  - 프로그램을 구성하는 데이터와 프로세스를 개별적인 모듈로 분류해서 구현하는 방식
    - 데이터와 프로세스를 분류해서 구현하려면 데이터와 프로세스 중 어떤 것을 먼저 구현할지 순서를 정해야 함
  - 절차적인 방식에서는 **데이터를 먼저 정의**하고, **이후 프로세스를 정의**함

- **데이터 구현**
  - 일반적으로 관계형 데이터베이스에 저장
  - -> 데이터베이스에 저장된 데이터를 메모리로 로드하기 위한 클래스 정의
  - 이때, 클래스 필드의 접근 제한자를 `private`으로 설정
    - 다른 클래스가 해당 필드에 직접 접근 불가능 -> **캡슐화**
    - 간접 접근을 위해 Getter/Setter 추가
- **프로세스 구현: 어떻게 처리할 것인가**
  - 영화 예매 프로세스를 위한 알고리즘을 4단계로 구성
    1. 데이터베이스로부터 필요한 객체 조회(메모리 로드)
    2. 할인 조건을 이용해서 할인 가능 여부 확인
    3. 할인 가능하다면 -> 할인 정책 이용해서 요금 계산 / 할인 안된다면 -> 정가로 요금 계산
    4. Reservation 생성 후 데이터베이스에 저장
  - 알고리즘을 정의했다면 이를 코드로 옮기기 -> `ReservationService`
    - 이때, 데이터베이스 접근을 위한 DAO 객체 생성 및 필드로 추가
    - `reserveScreening` 메소드를 만들고 앞서 정의한 알고리즘을 순서대로 작성

```java
public class ReservationService {
    private ScreeningDAO screeningDAO;
    private MovieDAO movieDAO;
    private DiscountPolicyDAO discountPolicyDAO;
    private DiscountConditionDAO discountConditionDAO;
    private ReservationDAO reservationDAO;

    public ReservationService(ScreeningDAO screeningDAO,
                              MovieDAO movieDAO,
                              DiscountPolicyDAO discountPolicyDAO,
                              DiscountConditionDAO discountConditionDAO,
                              ReservationDAO reservationDAO) {
        this.screeningDAO = screeningDAO;
        this.movieDAO = movieDAO;
        this.discountConditionDAO = discountConditionDAO;
        this.discountPolicyDAO = discountPolicyDAO;
        this.reservationDAO = reservationDAO;
    }

    public Reservation reserveScreening(Long customerId, Long screeningId, Integer audienceCount) {
        // 1. 데이터베이스로부터 필요한 객체 조회(메모리 로드)
        Screening screening = screeningDAO.selectScreening(screeningId);
        Movie movie = movieDAO.selectMovie(screening.getMovieId());
        DiscountPolicy policy = discountPolicyDAO.selectDiscountPolicy(movie.getId());
        List<DiscountCondition> conditions = discountConditionDAO.selectDiscountConditions(policy.getId());

        // 2. 할인 조건을 이용해서 할인 가능 여부 확인 (너무 길어지므로 별도의 메소드로 구현 후 이를 호출하도록 함)
        DiscountCondition condition = findDiscountCondition(screening, conditions);

        // 3.  할인 가능하다면 -> 할인 정책 이용해서 요금 계산 / 할인 안된다면 -> 정가로 요금 계산
        // 마찬가지롤 `calculateDiscount`라는 별도의 메서드를 호출
        Money fee;
        if (condition != null) { // null이 아니라면 할인 가능
            fee = movie.getFee().minus(calculateDiscount(policy, movie));
        } else { // 할인 불가능
            fee = movie.getFee();
        }

        // 4. Reservation 생성 후 데이터베이스에 저장
        Reservation reservation = makeReservation(customerId, screeningId, audienceCount, fee);
        reservationDAO.insert(reservation);

        return reservation;
    }

    // 할인 조건을 이용해서 할인 가능 여부 확인을 위한 메서드

    /**
     * DiscountCondition의 타입이 무엇이고, 타입에 따라 어떤 일을 해야 하는지를
     * DiscountCondition이 아니라, 외부의 ReservationService가 대신 판단하고 결정하고 있음
     * 절차적인 방식으로 작성된 코드에서 흔히 볼 수 있는 사례
     * 객체의 타입을 판단하고, 타입에 따라 어떤 일을 할지를 외부에서 결정하고 있다면? -> 절차적인 방식의 코드
     */
    private DiscountCondition findDiscountCondition(Screening screening, List<DiscountCondition> conditions) {
        // 루프를 돌며 DiscountCondition의 타입이 기간 조건인지 체크하고, 상영 시간을 이용해서 할인 여부 판단
        for (DiscountCondition condition : conditions) {
            if (condition.isPeriodCondition()) { // 기간 조건이라면
                if (screening.isPlayedIn(condition.getDayOfWeek(),
                        condition.getStartTime(),
                        condition.getEndTime())) {
                    return condition;
                }
            } else { // 순서 조건이라면
                if (condition.getSequence().equals(screening.getSequence())) { // 상영의 회차를 이용해서 할인 여부 판단
                    return condition;
                }
            }
        }

        return null;
    }

    // 할인 금액 계산 메서드
    // findDiscountCondition과 유사한 형태
    // DiscountPolicy의 타입을 판단하고 어떤 일을 해야 하는지를 ReservationService가 대신 결정하고 있음
    // 역시 제 3의 객체가 객체의 타입을 판단하고 수행하는 형태 -> 절차적인 방식
    private Money calculateDiscount(DiscountPolicy policy, Movie movie) {
        if (policy.isAmountPolicy()) {
            return policy.getAmount();
        } else if (policy.isPercentPolicy()) {
            return movie.getFee().times(policy.getPercent());
        }

        return Money.ZERO;
    }

    // Reservation 생성 메서드
    private Reservation makeReservation(Long customerId, Long screeningId, Integer audienceCount, Money fee) {
        return new Reservation(customerId, screeningId, audienceCount, fee.times(audienceCount));
    }
}
```

- **객체의 타입을 판단하고, 타입에 따라 어떤 일을 할지를 외부에서 결정하고 있다면?** -> 절차적인 방식의 코드

## 절차적인 설계의 핵심

- 절차적인 설계는 데이터와 프로세스를 분리된 개별적인 모듈로 구현하며, 일반적으로 데이터를 먼저 설계함
  - 중요한 부분은, 데이터를 설계할 때 데이터가 사용될 **문맥을 고려하지 않은 채** 독립적으로 데이터 설계한다는 점
- 데이터가 완성된 후에 외부의 프로세스에 데이터를 조합하고 처리하기 위한 로직(알고리즘) 구현
  - 데이터를 사용하는 방식은 프로세스가 결정하기 때문에 데이터를 설계할 때는 **데이터가 사용될 프로세스에 대해서는 전혀 고려하지 않음**
  - 문맥을 고려하지 않으면 유지보수성 측면에서 다양한 문제 발생

## 중앙집중식(Centralized) 제어 스타일

- 제어가 프로세스를 구현한 객체 안으로 집중되는 방식
- 보통 절차적 방식으로 작성된 코드의 제어 스타일
  - **프로세스를 구현한 클래스(ex. `ReservationService`)에 제어가 집중되는 특징**이 있음
  - `ReservationService`가 데이터 접근 객체나 데이터를 저장하고 있는 객체 모두의 실행 흐름을 통제하고 있음
- 제어가 한 고셍 집중되면 응집도와 결합도 측면에서 코드 수정 시 많은 문제 발생

> +) **불변 객체**의 사용
> 불변 객체는 자신의 상태를 변경하지 않고 변경된 상태를 가지는 새로운 객체를 반환함
> 불변 객체를 사용하면 부수 효과가 발생하지 않기 때문에 코드의 결과를 예측하기가 쉬움

## 절차적인 설계의 단점

- **_데이터를 구현한 코드의 수정에 취약하다_**

  - 절차적 방식에서는 **여러 프로세스가 데이터를 공유**함 -> 데이터가 변경되면 **데이터에 의존하는 하나 이상의 프로세스가 동시에 수정**됨
    - = **요구사항 변경에 취약함**
      - ex) 새로운 할인 조건의 추가될 경우
        - `DiscountCondition` 클래스에 enum 추가
        - `ReservationService`의 `findDiscountCondition` 메서드에서 조건 분기 하나 추가
    - 조합 조건을 추가하기 위해 **데이터인 `DiscountCondition` 수정 + 이를 사용하는 프로세스(`ReservationService`)가 함께 수정**됨
    - = **코드 개선 어려움**
      - 마찬가지로 코드 개선을 위해 일부 필드를 수정하더라도, 이를 사용하는 프로세스 쪽에서의 코드 수정 필요

- **`의존성(Dependency)`**

  - A가 B를 사용한다면 A가 B에 의존한다고 말함
  - 의존성이라는 용어 안에는 **변경이라는 개념이 포함되어 있음**
    - = 다른 코드가 수정될 때 함께 수정될 수 있는 가능성
  - **클래스 안에 포함된 다른 클래스의 텍스트는 의존성을 의미**
    - 어떤 클래스의 코드 안에 다른 클래스의 요소가 포함되어 있다면 두 클래스 사이에 의존성이 있음
    - A의 코드를 변경하면, 이에 의존하는(이를 사용하는) 모든 곳에서 함께 수정이 **변경될 가능성이 있음**
      - 클래스 이름이 변경될 때
      - A의 내부 구조가 변경될 때(ex. 메서드 시그니처가 변경될 때)
  - **변경의 방향과 의존성의 방향은 서로 반대**
  - 변경과 의존성이 서로 관련이 있기 때문에 **변경하기 쉬운 설계를 하기 위해서는 의존성을 통제해야 함**

- 절차적인 방식에서는 데이터 모듈과 프로세스 모듈이 분리되고, **프로세스 모듈이 데이터 모듈에 의존하는 형태**

  - 프로세스는 데이터에 의존하고, 변경의 방향은 의존성과 반대이기 때문에
  - 데이터가 수정될 때 프로세스로 변경의 영향이 전파될 가능성이 매우 높음
  - 데이터가 수정되더라도 프로세스쪽으로 영향이 전파되지 않도록 '전통적인 캡슐화 기법'인 `private` 사용 & getter/setter를 사용헀음
  - 하지만, getter/setter는 필드의 정의를 그대로 외부에 드러냄으로써 캡슐화 원칙을 위배함
    - 즉, **겉으로 보기에는 필드를 성공적으로 캡슐화하는 것처럼 보이지만, 실제로는 getter/setter를 이용해서 내부의 데이터를 그대로 노출하고 있음**
  - 이러한 문제가 발생하는 이유? => **데이터 설계 시 데이터가 사용될 문맥을 고려하지 않았기 때문**
    - 데이터가 어떻게 사용될지 모르는 상황에서 이를 사용 가능하게 만들기 위해 내부 정보를 그대로 드러내버렸음 by getter/setter
    - 이처럼 **문맥과 무관하게** 어떠한 상황에서도 데이터를 사용 가능하도록 **내부의 데이터를 그대로 노출**하는 설계 방식 => \* \*`추측에 의한 설계 전락(Design-By-Guessing Strategy`\*\*

- **_파급효과 제어의 어려움_**
  - 데이터 설계 시 문맥을 전혀 고려하지 않았기 때문에(by 추측에 의한 설계) **어떤 클래스가 이 데이터를 사용하는지 파악하기 어려움**
  - 또한, **다른 클래스가 사용하는 방식을 통제하기도 어려움**
  - => **코드 수정 시 이 영향이 어디까지 전파될지 예측하기가 쉽지 않음**

=> 수정하기 쉬운, 변경에 용이한 설계를 위해서는 **데이터 변경으로 인한 파급 효과를 막는 것이 핵심!**
=> 이 문제를 해결하기 위한 가장 좋은 방식은 **'데이터와 프로세스를 하나의 모듈로 합치는 것'**
=> **데이터와 프로세스를 동일한 모듈 안에 위치시켜 하나의 모듈 안에서만 변경이 발생하도록 개선**
=> **데이터를 사용하는 프로세스를 해당 데이터 안으로 이동시키자!**
=> 객체지향의 바탕을 이루는 가장 기본적인 개념
